%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Úvod}
V mnohých oblastiach informatiky je potrebné efektívne pracova» s funkciami nad
binárnimi premennými. Mô¾e ís» napríklad o efektívnu reprezentáciu hardwarových
komponént pri návrhu logických obvodov, reprezentáciu veµkých matíc v matematických
knihovniach alebo o reprezentáciu stavového priestoru vo formálnej verifikácií.
Existuje niekoµko prístupov pre repzrezentáciu týchto funkcií, prièom jedným z najpou¾ívanej¹ích
sú binárne rozhodovacie diagramy(BDD).
\par
BDD reprezentuje funkciu nad binárnimi premennými kompaktne pomocou koreòového 
acyklického orientovaného spojitého grafu. Nad týmto grafom sa dajú uplatòova»
mnohé algoritmy, ktoré zni¾ujú jeho pamä»ovú aj èasovú nároènos».
\par
Úèelom práce je navrhnú» a implementova» vlastnú kni¾nicu pre prácu s BDD,
porovna» výsledky s u¾ existujúcimi kni¾nicami. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Binárne rozhodovacie diagramy}
Táto kapitola sa venuje vzniku a základnému princípu práce s BDD.
\par
Binárne rozhodovacie stromy, anglicky {\it \uv{Binary Decision Diagrams}}, je dátová ¹truktúra
vyu¾ívaná v~rôznych odvetviach informatiky. Reprezentuje sa rôzne, èi u¾ graficky v~podobe
acyklického koreòového grafu, matematickými zápismi, alebo logickými funkciami.
%
% http://www.math.fme.vutbr.cz/download.aspx?id_file=3582
%
%
\section{Výroková logika}
Výroková logika skúma spôsoby tvorby zlo¾ených výrokov z jednoduchých a pravdivos» (nepravdivos»)
zlo¾eného výroku v závislosti od pravdivosti jednoduchých z ktorých je zlo¾ený. Celá kapitola
o výrokovej logike je prevzaná z literatúry\cite{Slapal}.
\par
Buï $P$ neprázdna mno¾ina prvotných formúl, ktoré hrajú úlohu jednoduchých výrokov.
Z jednoduchých výrokov získaváme zlo¾ené výroky spájaním pomocou logických spojok.
Poznáme nasledujúce logické spojky:
\begin{itemize}
\item{$\neg$ negácia}
\item{$\vee$ disjunkcia}
\item{$\wedge$ konjunkcia}
\item{$\rightarrow$ implikácia}
\item{$\equiv$ ekvivalencia}
\end{itemize}
Symbolmi jazyka $L_P$ výrokovej logiky nad mno¾inou $P$ sú prvky mno¾iny $P$, logické
spojky a zátvorky (,). Skladanie Zlo¾ených výrokov sa riadí týmito pravidlami:
\begin{enumerate}
\item Ka¾dá prvotná formula $p\in P$ je výroková formula.
\item Pokiaµ sú $A$, $B$ výrokové formule, potom ($\neg A$),($A\vee B$),($A\wedge B$),
($A\rightarrow B$) a ($A\equiv B$) sú výrokové formule.
\item Ka¾dá výroková formula je poskladaná koneèným poètom symbolov jazyka $L_P$,
ktorá vznikne podµa predchádzajúcich pravidiel.
\end{enumerate}
\par
Pravdivostné ohodnotenie prvotných formulí je µubovoµné zobrazenie mno¾iny $P$ na
hodnoty {\it true} a {\it false}. Pre jednoduchos» budeme znaèi» {\it true} 1 a {\it false} 0.
Formálny zápis je $v:P\rightarrow\{0,1\}$. Indukciou podµa zlo¾itosti formule definujeme
rozlo¾enie $w$ na zobrazenie $v$ na mno¾inu v¹etkých formulí jazyka $L_P$.
\begin{enumerate}
\item $w(p)=v(p)$ pre v¹etky $p\in P$
\item pokiaµ $A$, $B$ sú výrokové formule, potom $w(\neg A)$, $w(A\vee B)$, $w(A\wedge B)$, 
$w(A\rightarrow B)$ a~$w(A\equiv B)$  v závistosti od $w(A)$ a~$w(B)$ sa definujú podµa 
nasledujúcej tabuµky:
\end{enumerate}
\begin{center}
\begin{tabular}{|c|c||c|c|c|c|c|}
\hline
$w(A)$ & $w(B)$ & $w(\neg A)$ & $w(A\vee B)$ & $w(A\wedge B)$ &
$w(A\rightarrow B)$ & $w(A\equiv B)$ \\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
0 & 1 & 0 & 0 & 0 & 0 & 1 \\ 
1 & 0 & 0 & 0 & 1 & 1 & 0 \\ 
1 & 1 & 0 & 1 & 0 & 1 & 0 \\ \hline
\end{tabular}
\end{center}
\subsection{Mo¾nosti reprezentácie funckií}
Logické funkcie sa mô¾u reprezentova» rôznymi spôsobmi. Najèastej¹ie vyjadrenie je v podobe matematického
vzorca za pomoci vy¹¹ie spomínaných operátorov a funckií. Ma» v¹ak v poèítaèi funkciu ulo¾enú ako textový
re»azec veµmi komplikuje prácu s òou, preto sa vyvynuli rôzne dal¹ie reprezentácie. Operátory logických 
funckií sa väè¹inou prevádzajú po rade z $\vee, \wedge, \neg$ na $+, *, !$.
\paragraph{Pravdivostná tabuµka}
Najprehµadnej¹í a najµah¹ie nauèiteµný typ uchovávania logickej funkcie, bohu¾ial obsahuje veµké mno¾stvo 
redundancie a mô¾e ma» veµké pamä»ové nároky ($2^n$, kde $n$ je poèet premenných funkcie).
\paragraph{Karnaughova mapa}
¥ahko nauèiteµný formát s rovnakou pamä»ovou zlo¾itos»ou zlo¾itos»ou ako pravdivostná tabuµka. Veµmi vhodný
na minimalizáciu.
\paragraph{Logický obvod}
Nie moc prehµadný ani µahko nauèiteµný formát, ale vynikajúcí na demo¹tráciu pokroèilých systémov zlo¾ených
z logických funkcií.
\paragraph{BDD}
Formát v podobe acyklického koreòového grafu, ktorému sa budeme ïalej venova» v kapitole \ref{TypyBDD}.
\par
Existuje veµké mno¾stvo rôznych popisov logickej funkcie, z ktorých ka¾dý má svoje výhody aj nevýhody.
V prípade potreby nie je problém vytvori» vlasnú konvenciu pre zápis funkcie. Vo väè¹ine prípadov by
¹lo v¹ak iba o podmno¾inu u¾ existujúcej konvencie.
\subsection{Minimalizácia}
Minimalizácia logickej funkcie je proces zni¾ovania pamä»ových nárokov funkcie. V podstate ide oba o odstránenie
redundancí v ulo¾enej ¹truktúre. V prípade matematického popisu mô¾e ís» o uplatnenie rôznych výrokových teorémov
a viet. Podrobnéj minimalizácií BDD sa budeme venova» v kapitole \ref{TypyBDD}.
\subsection{Poèet funkcií}\label{logfce}
Poèet mo¾ných správaní sa logickej funkcie závisí od poètu premenných, ktoré ju ovplyvòujú a poètu hodnôt,
ktoré ka¾dá premenná mô¾e nadobudnú». V podstate ide o jednoduchú kombinatoriku, kde zis»ujeme v¹etky
variacie vstupných hodnôt, teda $p=n^k$, kde $n$ je poèet hodnôt, ktoré mô¾e nadobúda» vstupná premenná, 
$k$ poèet vstupných premenných a $p$ je výsedny poèet mo¾ných vstupov funkcie.
\par
Výsledný poèet funkcií je permutácia závisiaca od poètu mo¾ných vstupných kombinácií a poètu hodnôt, ktoré
mô¾e nadobúda» výstup funkcie, teda $r=q^p$, kde $p$ je poèet vstupných kombinácií, $q$ je poèet hodnôt, 
ktoré mô¾e výstpná premenná nadobúda» a $r$ je poèet funkcií danej funkcie. Z tohto dostávame vzorec
\begin{equation}
r=q^{n^{k}}
\end{equation}
Názornej¹ie vyjadrenie je pomocou tabuµky pre dve vstupné premenné ($k$=2), dve vstupné hodnoty 
($n$=2) a dve výstupné hodnoty ($q$=2) $\rightarrow 2^{2^2}=16$ funkcií\\

\begin{center}
\begin{tabular}{|c|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multicolumn{2}{|c||}{Vstup}&\multicolumn{16}{c|}{Výstup} \\ \hline
% x & y  \\ \hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ \hline
1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ \hline
1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\ \hline
\end{tabular}
\end{center} 

\section{História}
BDD vznikli z~dôvodu úspornej¹iej reprezentácie logických funckií. Reprezentácia je
navrhnutá na základe Shanonovho expazného teorému\cite{Shannon}. Táto dátová ¹truktúra od vzniku 
v~1959\cite{Lee} pre¹la mnohými úpravami na zní¾enie èasovej a~pamä»ovej nároènosti.
\par
Najvýznamnej¹ím milníkom v~oblasti redukcie pamä»ovej nároènosti bola ¹túdia R. E. 
Bryanta\cite{Bryant} z~Univerzity Carnegie Mellon. Táto ¹túdia sa týka najmä poradia premenných 
a~zdieµania podgrafov. Toto sa dá poklada» za vznik ROBDD popísaných v~sekcií \ref{ROBDD}.

%
% vojnarove slidy
%
%

\section{Matematický popis}
Prevzaté z predná¹ky \cite{Vojnar}.
\par
BDD je reprezentácia logickej funkcie $\{0,1\}^k\rightarrow\{0,1\},k\geq 0$. 
Z pohµadu teorie grafov sa jedná o koreòový, orientovaný, spojitý acyklický graf.
Formálna definícia BDD nad mno¾inou premenných $M$ je
\begin{equation}
G=(N,T,var,low,high,root,val)
\end{equation}
\begin{itemize}
\item $N$ - koneèná mno¾ina neterminálnych stavov (uzlov).
\item $T$ - koneèná mno¾ina terminálnych stavov (listov), $N\cap T=\emptyset$.
\item $var : N\rightarrow M$ je interné pomenovanie uzlov.
\item $low, high : N\rightarrow N\cup T$ prechodová funkcia definuje vysokého
a nízkeho následníka pre daný úzol $n\in N$ pre premennú $var(n)$ so vstupom $0$ alebo $1$.
\begin{itemize}
\item graf je acyklický teda $\neg \exists n \in N.n(low\cup high)^+n$.
\end{itemize}
\item $root \in N\cup T$ je koreò grafu, teda $\forall n \in (N\cup T)\backslash\{root\}.root(low\cup high)^+n$.
Vstupné hrany do uzlú $root$ by poru¹ili acyklicitu grafu.
\item $val : T\rightarrow \{0,1\}$ je mapovacia funkcia hodnôt terminálnych uzlov
\end{itemize}
\section{Procedúra \emph{Apply()}} \label{apply}
Procedúra \emph{Apply()} aplikuje booleovskú funkciu na BDD. Mô¾e by» unárna, alebo
binárna, výnimoène ternárna. Procedúre sú predané v¹etky BDD s ktorými pracuje
a odkaz na funkciu, ktorú má vykona». Poèet funkcií je odvodený v kapitole \ref{logfce}.
Výsledkom procedúry je jedno BDD.
\par
Princíp práce funkcie je rekurzívny zostup od koreòa a¾ k terminálnym uzlom. Keï sa funkcia nachádza
v bode, ¾e pre oba stromy pre¹la rovnakú cestu a v oboch stromoch sa nachádza na terminálnom uzle,
zapí¹e sa táto cesta do nového stromu a novému terminálnemu uzlu sa priradí hodnota výsledku
po¾adovanej logickej funkcie nad dvoma pôvodnými terminálnymi uzlami.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typy BDD}\label{TypyBDD}
V tejto kapitole si popí¹eme niektoré základné typi BDD, zdôrazníme rozdiely medzi nimi a objasníme, 
v èom sú niektoré efektívnej¹ie ako iné. Základné princípy budeme demon¹trova» na funkcii
\begin{equation}
f(x_1,x_2,x_3)=(\neg x_1\wedge \neg x_2 \wedge \neg x_3)\vee(x_1\wedge \neg x_2\wedge \neg x_3)\vee(x_1\wedge x_2\wedge \neg x_3)
\end{equation}
\par
V texte budeme pou¾íva» nasledujúcu notáciu
\begin{itemize}
\item premenné sa znaèia $x_i$, kde $i$ je poradie premennej
\item uzly sa znaèia písmenom $n_{ij}$, kde $i$ je index premennej a $j$ je poradové èíslo
uzlu oznaèovaného premennou
\end{itemize}
Príklad: $n_{23}$ znaèí tretí uzol premennéj $x_2$.
\section{BDD}\label{ROBDD}
BDD sa vytvára ako koreòový graf. Koreò tvorí jedna z premenných, väè¹inou sa berie prvá premenná funkcie, teda
v na¹om prípade $x_1$. Vytvoríme teda uzol $n_{11}$, ktorý je mapovaný na premennú $x_1$. Premenná mô¾e
nadobúda» dvoch hodnôt, pre ktoré sú definované nasledujúce uzly mapované na nasledujúcu premennú (uzly $n_{21}$ 
a $n_{22}$ mapované na premennú $x_2$). Takto sa postupne zanorujeme, a¾ prejdeme cez v¹etky premenné a vygenerujeme
v¹etky potrebné uzly. Hodnoty priradené za uzly mapované na poslednú premennú sú terminálne uzly.
Maximálny poèet generovaných uzlov je 
\begin{equation} \label{pocetUzlov}
\sum_{i=0}^{k} 2^i
\end{equation}
kde $k$ je poèet premenných.

\subsection{Základné BDD}
Grafické znázornenie na¹ej funkcie je na obrázku \ref{picBDD}.
\begin{figure}[ht!]
  \includegraphics[bb=0 50 0 200]{fig/bdd1.eps}
  \caption{Základné BDD}
  \label{picBDD}
\end{figure}

\paragraph{Notácia}
Pre orientáciu v grafe je pou¾itá nasledujúca notácia
\begin{enumerate}
  \item Uzly
    \begin{itemize}
      \item znaèené krú¾kom
      \item hierarchicky usporiadané podµa poradia vyhodnocovania
      \item premenná ovplyvòujúca uzol je písaná vµavo
    \end{itemize}
  \item Hrany
    \begin{itemize}
      \item plná èiara vedie k vysokému následníkovi daného uzlu $high(n)$
      \item preru¹ovaná èiara vedie k nízkemu následníkovi daného uzlu $low(n)$
    \end{itemize}
  \item Terminály
    \begin{itemize}
      \item symbol $\perp$ znaèí hodnotu $false$
      \item symbol $\top$ znaèí hodnotu $true$
    \end{itemize}
\end{enumerate}
\par
Ako vidíme, pamä»ová zlo¾itos» je exponencialna, èo vlasne vidíme aj z rovnice \ref{pocetUzlov}. Èasová zlo¾itos»
nájdutia daného terminálneho uzlu je logaritmická. Táto reprezentácia v¹ak obsahuje mnoho redundancie, preto sa
nepou¾íva.
\subsection{Redukované BDD}
Poèet generovaných uzlov sa dá výrazne obmedzi» tým, ¾e sa nebudú generova» zbytoèné uzly.
Pri pohµade na obrázok \ref{picBDD} vidíme redundanciu v terminálnych uzloch. Terminálne uzly mô¾eme zlúèi»
do dvoch. Vzniká strom s redukovaným poètom terminálnych uzlov, ktorý je znázornený
na obrázku \ref{picRBDD1}.
\begin{figure}[ht!]
  \includegraphics[bb=0 0 0 200]{fig/bdd2.eps}
  \caption{BDD s redukovaným poètom terminálnych uzlov}
  \label{picRBDD1}
\end{figure}
\par
Ïal¹iou redukciou je zluèovanie izomorfných podstromov. Keï sa v BDD nachádzajú dva rôzne uzly, ktoré majú
rovnaké (izomorfné) podstromy, mô¾eme ich zlúèi» do jedného.

\paragraph{Izomorfizmus}\cite{Kovar} dvoch grafov $G_1(V_1,H_1)$ a $G_2(V_2,H_2)$ je definovaný ako vzájomne bijektívne zobrazenie
$f:V_1\rightarrow V_2$ a $g:H_1\rightarrow H_2$ také, ¾e µubovoµnej hrane $h\in H_1$ sú priradené vrcholy 
$x,y\in V_1 \Leftrightarrow$ hrane $g(h)\in H_2$ sú priradené vrcholy $f(x),f(x)\in V_2$.\\
Strom s odstránenými izomorfnými podstromamy je na obrázku \ref{picRBDD2}.
\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd3.eps}
  \caption{BDD s odstránenými izomorfnými podstromami}
  \label{picRBDD2}
\end{figure} 
\par
Ïal¹iou redukciou je vynechávanie uzlov, kde $low(n) = high(n),pre\ n\in N$. V podstate ide o to, ¾e ak sa
vysoký aj nízky následník odkazujú na podstromy, logická funkcia v tomto bode nezávisí od danej premennéj,
preto sa mô¾e tento uzol vynecha». Výsledný strom je na obrázku \ref{picRBDD3}.
\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd4.eps}
  \caption{Výsledné minimalizované BDD}
  \label{picRBDD3}
\end{figure}
\paragraph{RBDD} je klasické BDD, pre ktoré platia nasledujúce pravidlá:
\begin{enumerate}
\item $\neg\exists n\in N.low(n)=high(n)$
\item $\neg\exists x_1,x_2\in N \cup T.root(G_1)=x_1\wedge root(G_2)=x_2 \wedge G_1 \Longleftrightarrow G_2$
\end{enumerate}


\subsection{Redukované usporiadané BDD} 
Poradia vyhodnocovania premenných, ktoré ovplyvòujú uzly, majú veµký vplyv na poèet generovaných uzlov. 
Pre ilustráciu si to predveïme na funkcií
\begin{equation}
y(x_1,...,x_8) = (x_1 \wedge x_2)\vee(x_3 \wedge x_4)\vee(x_5 \wedge x_6)\vee(x_7 \wedge x_8)
\end{equation}
RBDD odpovedajúce danej funkcií je na obrázku \ref{picROBDD}.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=150mm]{fig/bdd5.jpg}
  \caption{Rozdiel medzi dobrým a zlým usporiadaním\cite{WikiOrder}}
  \label{picROBDD}
\end{figure}
\par
Obe BDD sú minimalizované a popisujú rovnakú logickú funckiu. Z pravého obrázku v¹ak vidíme, ¾e dobrým
usporiadaním výrazne zní¾ime poèet generovaných uzlov. Na zistenia dobrého usporiadania v¹ak neexistuje
doposiaµ ¾iadný algoritmus. Existujú iba rôzne heuristiky. Tie nám v¹ak mô¾u pomôc», teda dostaneme
výsledný strom s men¹ím poètom uzlom, ale aj u¹kodi». Tu je zoznam niektorých pou¾ívaných algoritmov:
%BDD-dip
\paragraph{Náhodný algoritmus}\cite{Rucky}
Algoritmus sa pou¾íva v dvoch variantách a to varianta s pivotom a varianta bez pivota.\\
Varianta bez pivota vyberá dve náhodné premenné v grafe a tie vymení postupným vymieòaním
susedných uzlov. Výsledné usporiadanie premenných pre danú iteráciu je ulo¾enie s najmen¹ím
poètom uzlov v priebehu itérácie. \\
Varianta s pivotom pracuje na rovnakom princípe, ale pred samotným algoritmom sa vyberie
pivot. To je premenná s najvy¹¹ím poètom uzlov. Dve náhodne zvolené premenné sú také, ¾e
jedna sa nachádza nad a druhá pod pivotom.
\paragraph{Sifting algoritmus} \cite{Rudell}
Teória je spoèíta» najvýhodnej¹iu pozíciu v grafe pre jednu premennú s tým, ¾e ostatné premenné
zachovajú svoje poradie. Premennú posúvame najskôr smerom k terminálnym uzlom, potom smerom
ku koreòu. Po príchode do koreòu vieme, v ktorej pozícií mala premenná najmenej uzlov a posunieme
ju tam. Posun sa vykonáva na základe prehadzovania susedných premenných.
\par
Iné pou¾ívané algoritmy sú napríklad
\begin{itemize}
  \item{Symmetric sifting algoritmus}
  \item{Group sifting algoritmus}
  \item{Window permutation algoritmus}
  \item{Algoritmus vyu¾ívajúci simulované ochladzovanie}
  \item{Algoritmus vyu¾ívajúci genetické algoritmy}
\end{itemize}
\section{Multiterminálne BDD}
Multiterminálne BDD sú vo svojej podstate obyèajné ROBDD, ktoré majú väè¹í, obecne neobmedzený
poèet terminálnych uzlov. Ako príklad si mô¾eme uvies» kombinaèný systém\footnote{Stav závisí iba 
na kombinácii vstupu}, ktorý sa mô¾e nachádza» v stavoch $S_{\mathit{off}}$, $S_{set}$ a $S_{count}$.
Vstupné premenné sú $X_{on}$ a $X_{count}$. Tabuµka systému je
\begin{center}
\begin{tabular}{|c|c||c|}
\hline
$X_{on}$ & $X_{count}$ & $S(X_{on}, X_{count})$ \\ \hline
0 & 0 & $S_{\mathit{off}}$ \\ \hline
0 & 1 & $S_{\mathit{off}}$ \\ \hline
1 & 0 & $S_{set}$ \\ \hline
1 & 1 & $S_{count}$ \\ \hline
\end{tabular}
\end{center}
\par
Na miminalizáciu MTBDD sa dajú pou¾i» opä» pou¾i» obe techniky, teda odstránenie izomorfných podstromov
a uzlov, kde $\mathit{high}(x)=\mathit{low}(x)$.
Podµa tabuµky jednoducho zostrojíme a zminimalizujeme BDD, ktoré v¹ak nemá iba 2 terminálne hodnoty ale 3.
\begin{figure}[ht!]
  \includegraphics[bb=-100 0 0 250]{fig/bdd6.eps}
  \caption{Príklad MTBDD}
  \label{picMTBDD}
\end{figure}

  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Porovnání dostupných programových balíkù pro manipulaci
% s binárními rozhodovacími diagramy, Martin Felcman, BP, 2008
% felcmm1_2008bach.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dostupné balíky}
V tejto kapitole si popí¹eme niektoré kni¾nice pracujúce s BDD. Bude
popísaná ¹truktúra uzlu a spôsob práce s diagramami.
\section{CUDD}
Balíèek bol vyvíjaný na univerzite v Colorádu. U¾ od roku 1996 stálym vývojom 
dosiahol vynikajúce pamä»ové a výkonnostné výsledky. Podporuje prácu s BDD, 
ADD a ZDD. V kni¾nici je taktie¾ implementovaná sada algoritmov na zlep¹enie
usporiadania premenných.
\par
Balíèek sa mô¾e pou¾íva» 3 spôsobmi:
\begin{enumerate}
\item {Black box} - umo¾òuje pou¾íva» iba exportované funkcie popísané v nápovede.
\item {Clean box} - umo¾nuje písanie zlo¾itej¹ích projektov, kde je vzhµadom k efektivite
nutné prida» do balíka vlastné funkcie.
\item {Interface} - OO jazyky umo¾nujú programátorom nestara» sa o správu pamäte.
\end{enumerate}

\subsection{©truktúra uzlu}
\begin{lstlisting}
struct DdNode{
  DdHalfWord index;
  DdHalfWord ref;
  DdNode *next;
  union{
    CUDD_VALUE_TYPE value;
    DdChildren kids;
  } type;
};
\end{lstlisting}
©truktúra reprezentuje terminálne aj neterminálne uzly. V premennej \texttt{index}
je ulo¾ený názov premennej, podµa ktorej je pomenovaný uzol. Odrá¾a poradie vzniku
uzlov. V premennej \texttt{ref} je poèítadlo referencií na uzol. Premenná \texttt{next}
ukazuje na daµ¹í uzol v unique table. Ak ide o terminálny uzol, obsahuje premennú 
\texttt{value}, ktorá znaèí hodnotu uzlu, ináè obsahuje ¹truktúru \texttt{kids}, kde sú
ulo¾ené ukazatele na vysokého a nízkeho následníka daného uzlu.
\subsection{Manager}
V¹etky pou¾ité uzly sú ulo¾ené v ¹pecialnej hashovaciej tabuµke (unique table). BDD a ADD
zdieµajú rovnakú tabuµku, ZDD má svoju vlastnú. Manager sa pred pou¾itím inicializuje
funkciou \texttt{Cudd\_Init()} a po pou¾ití ru¹í funckiou \texttt{Cudd\_Quit()}.
\subsection{Zhrnutie}
CUDD je univerzálny balíèek pre prácu s BDD. Má kvalitne spracovanú dokumentáciu
vèetne u¾ivateµského a programátorského manuálu. Výhodou je disponovanie ¹irokou
¹kálou funkcií pre radenie poradia premenných. 

\section{BuDDy}
Táto kni¾nica bola vytvorená ako súèas» dizertaènej práce. Spoèiatku bola urèená len
na demo¹tráciu princípov BDD. Vo svojej poslednej verzií je u¾ v¹ak plnohodnotným balíkom
so v¹etkými ¹tandartnými operáciami, radením a dokumentáciou.
\subsection{©truktúra uzlu}
\begin{lstlisting}
typedef struct s_BddNode{
  unsigned int refcou : 10;
  unsigned int level : 22;
  int low;
  int high;
  int hash;
  int next;
} BddNode;
\end{lstlisting}
Premenná \texttt{refcou} obsahuje poèet referencií vedúcich na uzol. Premenná 
\texttt{level} ukazuje pozíciu premennéj pri súèastnom ulo¾ení. Premenné \texttt{high}
a \texttt{low} reprezentujú hrany, \texttt{next} je ukazateµ na nasledujúci uzol.
Premenná \texttt{hash} je ukazateµ na koreò stromu.
\par
Je treba si uvedomi», ¾e knihovòa BuDDy nepracuje s managerom, ale s poµom,
preto sú prvky ¹truktúry iba indexy do poµa. Existuje tu v¹ak aj hash tabuµka. 
Tá je tu v¹ak za úèelom zvý¹enia efektívnosti pri prístupe k uzlom.
\subsection{Zhrnutie}
BuDDy je kompletný balík na prácu s BDD. Podporuje usporiadavanie premenných.
Podporuje taktie¾ prácu s booleovskými vektormi. BuDDy má veµmi kvalitne spracované
C\verb!++! rozhranie, ktoré zefektívòuje prácu s týmto balíkom.

\section{VATA}
Jedná sa o kni¾nicu implementovanú na Vysokom uèení technickom v Brne. Je napísaná
v jazyku C\verb!++!. Hlavné vyu¾itie kni¾nice je vo formálnej verifikácií, ale
je pou¾iteµná aj v iných odvetviach informatiky. VATA pou¾íva MTBDD na ulo¾enie tabuµky
prechodov automatu.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Návrh implementácie}
V tejto kapitole popí¹em svôj návrh implementácie jednotlivých dátových ¹truktúr a algoritmov.
Popí¹em taktie¾ problémy ktoré som mal poèas implementácie.
\section{Dátové ¹truktúry}
Èas» vysvetluje popis implementácie a prepojenia jednotlivých dátových ¹truktúr.
\subsection{BDD uzol}\label{tBddNode}
Základnou jednotkou ka¾dého diagramu je uzol. Môj návrh uzlu obsahuje v¹etky
dôle¾ité premenné pre úplnu prácu s ním.
\begin{lstlisting}
typedef struct BddNode{
  struct BddNode *high, *low;
  unsigned int var;
  unsigned int ref;
  struct BddNode *nextFree;
}tBddNode;
\end{lstlisting}
Premenné \texttt{high} a \texttt{low} sú ukazatele na vysokého a nízkeho následníka uzlu. V prípade, ¾e ide 
o terminálny uzol, \texttt{high} a \texttt{low} sú nastavené na \texttt{NULL}. Na zistenie, èi je daný uzol
terminálny sa pou¾íva makro \texttt{isTerminal(t)}. Premenná \texttt{var} je index do tabuµky návestí premenných, 
o ktorej si viac povieme v sekcií \ref{tLabels}. Premenné \texttt{ref} a \texttt{nextFree} sú premenné, ktoré 
vyu¾íva garbage collector. \texttt{ref} je poèítadlo referencií, ktoré je dôle¾ité pri zdielaných uzloch 
a \texttt{nextFree} je ukazateµ, ktorý previazáva zoznam voµných premenných ktoré má k dispozícií manager. 
Viac v kapitole \ref{tManager}.

\subsection{Garbage collector}\label{tGarbage}
Garbage collector má jednoduchú ¹truktúru.
\begin{lstlisting}
typedef struct Garbage{
  tBddNode *nodes;
  struct Garbage *next;
}tGarbage;
\end{lstlisting}
Premenná \texttt{nodes} ukazuje na pole v¹etkých uzlov a premenná \texttt{next} na pola ïal¹ieho kusu pamäti,
ktorý sa alokuje v prípade, ¾e manager nemá voµné uzly.

\subsection{Návestia premenných} \label{tLabels}
Je indexované pole re»azcov. ©truktúra je taktie¾ veµmi jednoduchá.
\begin{lstlisting}
typedef struct Labels{
  char **lab;
  unsigned int count;
}tLabels;
\end{lstlisting}
Premenná \texttt{lab} je odkaz na pole re»azcov\footnote{Re»azcom je myslený typ \texttt{char *}.} a \texttt{count} 
je premenná oznaèujúca poèet re»azcov, pou¾ívana hlavne pri realokácií prvej úrovne \texttt{lab}.

\subsection{Medzivýsledky\,--\,\emph{Cache}} \label{tCache}
Medzivýsledkami sa rozumejú nacachované uzly, ktoré zni¾ujú pamä»ovú zlo¾itos» a veµmi zjednodu¹ujú
zdielanie podgrafov. ©truktúra je nasledujúca.
\begin{lstlisting}
typedef struct Cache{
  unsigned int var;
  tBddNode *high, *low, *record;
  struct Cache * next;
} tCache;
\end{lstlisting}
©truktúra Cache je zoznam, ktorého previazanie zais»uje premenná \texttt{next}. 
Ulo¾ené uzly sa cacheujú ako trojica $[\mathit{var},\mathit{high},\mathit{low}]$.
Záznamy ¹truktúry Cache tomu odpovedajú. Pri prehµadávaní cache sa sa táto trojica
porovnáva s trojicou uzlu, ktorý kontrolujeme. V prípade zhody premenná \texttt{record}
obsahuje ukazateµ na u¾ vytvorený uzol.

\subsection{BDD manager}\label{tManager}
Zastre¹ujúca ¹truktúra, riadiaca celú tvorbu a úpravy BDD.
\begin{lstlisting}
typedef struct Manager{
  tGarbage *nodes;
  tBddNode *free;
  tLabels *variables;
  tLabels *terminals;
  tCache *cache;
}tManager;
\end{lstlisting}
\texttt{nodes} je ukazateµ na ¹truktúru garbage collectoru, ktorá ma nastarosti uvoµnovanie a vytváranie nových
zhlukov uzlov. \texttt{free} je ukazateµ na prvý voµný uzol. Ide opä» o zoznamovú implementáciu, kde sú v¹etky
uzly prepojené pomocou \texttt{nextFree}, viz \ref{tBddNode}. \texttt{cache} je zoznam nacachovaných uzlov.
\texttt{variables} a \texttt{terminals} sú návestia uzlov.
\subsection{Chyby}
Enumerácia v¹etkych chybových stavov balíka a odpovedajúce správy pre u¾ivateµa pomocou makra \texttt{throwError(e)}.

\section{Algoritmy}
Hlavné u¾ivateµské rozhranie tvoria funkcie \texttt{bddInit()}, ktorá inicializuje v¹etky komponenty pre manager,
\texttt{bddDestroy()}, ktorá uvoµnuje v¹etky prostriedky, ktoré daný manager alokoval, \texttt{bddCreateNode()} 
a \texttt{bddCreateTerminal()}, ktoré vytvoria uzol pre danú premennú alebo terminál a funkcia
\texttt{bddApply()}.
\subsection{Inicializácia}
®iadnu z operácií nie je mo¾né prevádza» nad neinicializovaným managerom. Na inicializáciu slú¾i funkcia
\texttt{bddInit()}, ktorá postupne inicializuje v¹etky prvky ¹truktúry. Najdôle¾itej¹iu èas»ou je inicializácia
premennej \texttt{nodes}, ktorá vytvorí pole uzlov podµa zadanej veµkosti. V¹etky tieto uzly sú prístupné 
zo zoznamu v premennej \texttt{free}. Automaticky sa generujú dva uzly \texttt{bddFalse} a \texttt{bddTrue}
prístupné na globálnej úrovni.
\par
Inicializáciu zvy¹ných komponent tvorí zväè¹a nastavenie ukazateµa aktívnej èasti ¹truktúry na \texttt{NULL}.
\subsection{Uvolòovanie}
Na uvolnenie slú¾i funkcia \texttt{bddDestroy()}, ktorá postupne zru¹í v¹etky alokované ¹truktúry.
Je neprípustné ukonèi» program pred zavolaním tejto funkcie, preto ¾e by dochádzalo k únikom pamäti\footnote{
Memory leak je blok pamäti príslu¹iaci ukonèenému programu.}.
\par
Postupne sa uvolòujú prostriedky garbage collectora, tj. zru¹ia sa uzly a potom sa dealokuje ¹truktúra.
Je potreba dáva» pozor na to, ¾e garbage collector je v podsate zoznam, teda je potrebné ho uvolni»
korektne celý a nie iba prvý blok pamäti. Cache tvorí taktie¾ zoznam, preto sa musí uvolòova» postupne.
Uvolnenie ¹truktúry návestí je iba volanie funkcie \texttt{free()} nad premennou ¹truktúry \texttt{lab}.
Ïalej sa u¾ uvolòuje iba samotná ¹truktúra.
\subsection{Vytvorenie uzlu}
Na vytváranie uzlov sa pou¾íva funkcia \texttt{bddCreateNode()}. Funckia ukladá návestie vytváraného
uzlu do premennej manager \texttt{variables}. V uzle sa nastavia v¹etky jeho informácie a to takto:
\begin{enumerate}
  \item nastavíme premennú \texttt{var} na index v tabuµke \texttt{variables}
  \item poèítadlo referencií \texttt{ref} nastavíme na 1
  \item oznaèíme uzol ako pou¾ívaný nastavením \texttt{nextFree} na \texttt{NULL}
  \item vysokému následníkovi \texttt{high} priradíme \texttt{bddTrue}
  \item nízkemu následníkovi \texttt{low} priradíme \texttt{bddFalse}
  \item pozrieme do cache, èi u¾ takýto uzol neexistuje a vraciame ukazateµ
\end{enumerate}
V prípade nového terminálneho uzla sa pou¾íva funkcia \texttt{bddCreateTerminal()}.
Sú tu iba nepatrné zmeny:
\begin{itemize}
  \item návestie sa vkladá do tabuµky \texttt{terminals}
  \item referencie sa na terminálnych uzloch nepoèítajú
  \item do \texttt{high} a \texttt{low} priradíme \texttt{NULL}
\end{itemize}
Vytváranie MTBDD je vo svojej podstate rovnaké ako vytváranie obyèajného BDD s rozdielom,
¾e na vytvorenie uzlu sa pou¾íva funkcia \texttt{mtbddCreateNode()}. Tá okrem ¹tandartných
parametrov funkcie \texttt{bddCreateNode()} príjma aj ukazatele na následníkov. 

\subsection{Práca s mezdivýsledkami\,--\,\emph{Cacheovanie}}
Ka¾dý vytvorený uzol (s výnimkou terminálnych) sa ukladá do ¹truktúry uvedenej
v èasti \ref{tCache}. Ukladajú sa ako trojica vysokého následníka, nízkeho následníka
a návestia premennej. Pri vytváraní uzlu sa uzol najskôr vytvorí, potom sa pozrie do
cache pomocou funkcie \texttt{cacheCheck()}. Ak daný uzol u¾ existuje, funkcia vracia ukazateµ
na uzol. Pôvodne vytvorený uzol sa ru¹í a ako výsledok sa vracia uzol ukazujúci na 
u¾ existujúci uzol, ktorého ukazateµ sme vytiahli z cache. V prípade ¾e uzol e¹te neexistuje,
vytvára sa nový cache záznam pomocou funkcie \texttt{cacheInsert()}, ktorá na zaèiatok
zoznamu pridáva daný uzol. V prípade, ¾e poèítadlo referencií \texttt{ref} nejakého uzlu
padne na nulu, uzol je uvoµnený a cache záznam zru¹ený.
\subsection{Procedúra \emph{Apply()}}
Základný princíp procedúry bol u¾ popísaný v èasti \ref{apply}. Implementáciu v kni¾nici
tvoria dve funkcie. Prvá je \texttt{bddApply()}, ktorá sa volá z u¾ivateµského programu.
Ako parameter dostáva dva ukazatele na diagramy (typ \texttt{tBddNode $*$}), manager, 
v ktorom sa má procedúra vykona» (typ \texttt{tManager $*$}) a odkaz na funkciu
vracajúcu nový diagram (typ \texttt{tBddNode $*(*)()$}). Funkcia spú¹»a rekurzívnu
funkciu \texttt{\_apply()} s rovnakými parametrami. \texttt{\_apply()} sa rekurzívne
zanoruje podµa algoritmu \ref{algApply}.
\begin{algorithm}[h]
  \caption{\_apply} \label{algApply}
  \SetAlgoLongEnd
  \LinesNumbered
  \SetNlSty{normal}{}{:}
 
  \KwIn{$X,Y,\mathit{func}$}
  \KwOut{$\mathit{result}$}
\medskip
  \eIf{($X$ aj $Y$ sú terminály)}{
    \Return $\mathit{func}(X,Y)$ \;
  }{
    \eIf{($X$ je nad $Y$)}{
      vytvor uzol podµa $\mathit{var}_X$\;
      zanor $X$\;
    }{
      \eIf{($Y$ je nad $X$)}{
        vytvor uzol podµa $\mathit{var}_Y$\;
        zanor $Y$\;
      }{
        vytvor uzol podµa jednej z premenných\;
        zanor obe premenné\;
      }
    }
  }
  $\mathit{result}=\mathit{\_apply(X,Y,\mathit{func})}$\;
  \medskip
  \eIf{$(\mathit{low_{result}=high_{result}})$}{
    $\mathit{result=low_{result}}$\;
  }{
    \If{$(\mathit{result}$ je v $\mathit{cache})$}{
      uvolni $\mathit{result}$\;
      \Return cacheovaný záznam\;
    }
  }
  \medskip
  \Return $\mathit{result}$\;
\end{algorithm}

Pri vytváraní nových uzlov v procedúre sa pou¾íva funkcia \texttt{bddNewNode()},
ktorá má rovnaké správanie ako \texttt{bddCreateNode()} s rozdielom, ¾e nekontroluje
cache. Cache sa kontroluje a¾ na konci procedúry spolu s kontrolovaním, èi potomkovia
nie sú rovnakí.
\par
Kni¾nica disponuje základnými logickými funkciami, ktoré mô¾u by» ako parameter funkcie
\texttt{bddApply()}. Tieto funkcie sú \texttt{bddOr()}, \texttt{bddNor()}, \texttt{bddAnd()},
\texttt{bddNand()}, \texttt{bddXor()} a \texttt{bddNeg()}. Funkcia \texttt{bddNeg()}, sa prakticky
nikdy nezavolá, lebo vo funckií \texttt{bddApply()} sa funkcia \texttt{bddNeg()} transformuje
na funkciu \texttt{bddNand()} a ako korene oboch diagramov sa predá rovnaký ukazateµ.
\par
Za zmienku tie¾ stojí, ¾e funkcia \texttt{bddApply()} znièí ukazatele predané ako parameter.
je to spôsobené tým, ¾e procedúra nemodifikuje BDD, ale vytvára úplne nové.

\subsection{Práca s MTBDD}
Ako bolo u¾ vy¹¹ie spomínané, kni¾nica pracuje na globálnej úrovni kvôli premenným
\texttt{bddTrue} a \texttt{bddFalse}. Balík taktie¾ disponuje mno¾inou základných
operácií nad binárnymi premennými. Pri práci s MTBDD u¾ivateµ vytvára vlastné terminálne
uzly na globálnej úrovni a vlastné funkcie pre prácu s týmito uzlami.
\par
Je dôle¾ité poznamena», ¾e pri práci s MTBDD je veµmi dôle¾itou èas zvládnu» návrh prechodovej
funkcie systému.

\subsection{Uká¾ky kódov}
Predvedieme si niektoré kon¹trukcie, ktoré sa vyu¾ívajú na tvorbu rozhodovacích diagramov.
\subsubsection{Jednoduchá binárna funkcia}
Nasledujúci kód vytvorí funkciu 
$$f(a,b,c) = (a\wedge b) \vee (\neg a\wedge c)$$

\begin{lstlisting}
#include"bdd.h"

int main(){
  tError e;
  tManager manager;
  tBddNode *a,*b,*c;

  e = bddInit(&manager,BDD_SMALL);
  if(e) bddThrowError(e);
  
  bddCreateNode(&manager,"A",&a);       // A
  bddCreateNode(&manager,"B",&b);       // B
  b = bddApply(&manager,b,NULL,bddNeg); // !B
  a = bddApply(&manager,a,b,bddAnd);    // (A * !B)
  
  bddCreateNode(&manager,"C",&c);       // C
  bddCreateNode(&manager,"D",&b);       // D
  c = bddApply(&manager,c,b,bddAnd);    // (C * D)

  a = bddApply(&manager,a,c,bddOr);     // (A * !B) + (C * D)

  printTree(&manager,a);

  bddDestroy(&manager);
  return 0;
}
\end{lstlisting}
V kóde si mô¾eme v¹imnú», ¾e niektoré ukazatele pou¾ívame viac krát. Je to z dôvodu, ¾e BDD
predané ako parametre funkcie \texttt{bddApply} sú uvoµnené.
\subsubsection{Práca s MTBDD}
Práca s MTBDD je o nieèo málo zlo¾itej¹ia pri koncepcií. Pre jednoduchos» som zvolil uká¾ku 
vytvorenia MTBDD popísaného na obrázku \ref{picMTBDD}. Dôle¾itá je správna analýza systému.
Je potrebné vytvori» nové terminálne uzly, ktoré vytvoríme pomocou funckie
\texttt{bbdCreateTerminal()}. Ïalej zostrojíme tabuµku výsledných stavov uplatnenia funkcie
na jednotlivé terminály. Tabuµka je nasledujúca
\begin{center}
\begin{tabular}{|c|c c c|}
\hline
$\mathit{func}(x,y)$ & $\mathit{S_{off}}$ & $\mathit{S_{set}}$   & $\mathit{S_{count}}$  \\ 
\hline
$\mathit{S_{off}}$   & $\mathit{S_{off}}$ & $\mathit{S_{off}}$   & $\mathit{S_{off}}$  \\ 
$\mathit{S_{set}}$   & $\mathit{S_{off}}$ & $\mathit{S_{set}}$   & $\mathit{S_{count}}$  \\ 
$\mathit{S_{count}}$ & $\mathit{S_{off}}$ & $\mathit{S_{count}}$ & $\mathit{S_{count}}$  \\ \hline
\end{tabular}
\end{center}
Tabuµka zna¾í prechodovú funckiu ná¹ho systému. Implementácia pomocou kni¾nice je nasledujúca
\begin{lstlisting}
#include"bdd.h"

// vytvorenie terminalov na globalnej urovni
tBddNode * Soff;
tBddNode * Sset;
tBddNode * Scount;

// prechodova funkcia systemu
tBddNode * func(tBddNode * x, tBddNode * y) {
  if(x == y) return x;
  if(x == Soff || y == Soff) return Soff;
  return Scount;
}

int main(){
  tError e;
  tManager manager;
  tBddNode *a,*b;

  e = bddInit(&manager,BDD_SMALL);
  if(e) bddThrowError(e);
  
  // inicializacia terminalov
  bddCreateTerminal(&manager,"S_off",&Soff);
  bddCreateTerminal(&manager,"S_set",&Sset);
  bddCreateTerminal(&manager,"S_count",&Scount);
  
  // vytvorenie uzlov
  mtbddCreateNode(&manager,"X_on_off",Sset,Soff,&a);
  mtbddCreateNode(&manager,"X_set_count",Sset,Scount,&b);

  // aplikacia funkcie
  a = bddApply(&manager,a,b,func);
  
  printTree(&manager,a);

  bddDestroy(&manager);
  return 0;
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Testy}
\section{Memory leaks}
\section{Rýchlos» vyhµadania uzlu}
\section{Rýchlos» procedúry \emph{Apply()} }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\chapter{Porovnanie s kni¾nicami CUDD a VATA}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závìr}

