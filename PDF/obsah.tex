\chapter{Úvod}
V mnohých oblastiach informatiky je potrebné efektívne pracova» s funkciami nad binárnimi premennými. Mô¾e ís» napríklad o efektívnu reprezentáciu hardwarových komponént pri návrhu logických obvodov, reprezentáciu veµkých matíc v matematických knihovniach alebo o reprezentáciu stavového priestoru vo formálnej verifikácií. Existuje niekoµko prístupov pre repzrezentáciu týchto funkcií, prièom jedným z najpou¾ívanej¹ích sú binárne rozhodovacie diagramy(BDD).

BDD reprezentuje funkciu nad binárnimi premennými kompaktne pomocou koreòového acyklického orientovaného spojitého grafu. Nad týmto grafom sa dajú uplatòova» mnohé algoritmy, ktoré zni¾ujú jeho pamä»ovú aj èasovú nároènos».

Úèelom práce je navrhnú» a implementova» vlastnú kni¾nicu pre prácu s BDD. Práca demon¹truje základné princípy algoritmov uplatnených nad BDD, mo¾nosti reprezentácie BDD v poèítaèi a súèas»ou je taktie¾ porovnanie dosiahnutých výsledkov s niektorými kni¾nicami.

Práca obsahuje v kapitole \ref{kap:logika} formálny popis výrokovej logiky, v kapitole \ref{kap:bdd} typy BDD, prevod binárneho rozhodovacieho stromu BDT na BDD, základný princíp procedúry apply a popis MTBDD. V kapitole \ref{kap:baliky} popí¹eme niektoré existujúce balíky pre prácu s BDD a MTBDD. Zvy¹ná èas» práce obsahuje popis návrhu, implementácie a testovania kni¾nice. Záver práce patrí zrovnaniu výsledkov s kni¾nicou CUDD.





\chapter{Výroková logika} \label{kap:logika}

Výroková logika skúma spôsoby tvorby zlo¾ených výrokov z jednoduchých a pravdivos» (nepravdivos») zlo¾eného výroku v závislosti od pravdivosti jednoduchých z ktorých je zlo¾ený. Celá kapitola o výrokovej logike je prevzaná z literatúry\cite{Slapal}.

Buï $P$ neprázdna mno¾ina prvotných formúl, ktoré hrajú úlohu jednoduchých výrokov. Z jednoduchých výrokov získaváme zlo¾ené výroky spájaním pomocou logických spojok. Poznáme nasledujúce logické spojky:
\begin{itemize}
  \item{$\neg$ negácia}
  \item{$\vee$ disjunkcia}
  \item{$\wedge$ konjunkcia}
  \item{$\rightarrow$ implikácia}
  \item{$\equiv$ ekvivalencia}
\end{itemize}

Symbolmi jazyka $L_P$ výrokovej logiky nad mno¾inou $P$ sú prvky mno¾iny $P$, logické spojky a zátvorky (,). Skladanie zlo¾ených výrokov sa riadí týmito pravidlami:
\begin{enumerate}
  \item Ka¾dá prvotná formula $p\in P$ je výroková formula.
  \item Pokiaµ sú $A$, $B$ výrokové formule, potom ($\neg A$),($A\vee B$),($A\wedge B$),($A\rightarrow B$) a ($A\equiv B$) sú výrokové formule.
  \item Ka¾dá výroková formula je poskladaná koneèným poètom symbolov jazyka $L_P$, ktorá vznikne podµa predchádzajúcich pravidiel.
\end{enumerate}

Pravdivostné ohodnotenie prvotných formulí je µubovoµné zobrazenie mno¾iny $P$ na hodnoty {\it true} a {\it false}. Pre jednoduchos» budeme znaèi» {\it true} 1 a {\it false} 0. Formálny zápis je $v:P\rightarrow\{0,1\}$. Indukciou podµa zlo¾itosti formule definujeme rozlo¾enie $w$ na zobrazenie $v$ na mno¾inu v¹etkých formulí jazyka $L_P$.
\begin{enumerate}
  \item $w(p)=v(p)$ pre v¹etky $p\in P$
  \item pokiaµ $A$, $B$ sú výrokové formule, potom $w(\neg A)$, $w(A\vee B)$, $w(A\wedge B)$, 
  $w(A\rightarrow B)$ a~$w(A\equiv B)$  v závistosti od $w(A)$ a~$w(B)$ sa definujú podµa nasledujúcej tabuµky:
\end{enumerate}

\begin{center}
  \begin{tabular}{|c|c||c|c|c|c|c|}
    \hline
    $w(A)$ & $w(B)$ & $w(\neg A)$ & $w(A\vee B)$ & $w(A\wedge B)$ &
    $w(A\rightarrow B)$ & $w(A\equiv B)$ \\
    \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
    0 & 1 & 0 & 0 & 0 & 0 & 1 \\ 
    1 & 0 & 0 & 0 & 1 & 1 & 0 \\ 
    1 & 1 & 0 & 1 & 0 & 1 & 0 \\ \hline
  \end{tabular}
\end{center}

\subsection{Mo¾nosti reprezentácie funckií}
Logické funkcie sa mô¾u reprezentova» rôznymi spôsobmi. Najèastej¹ie vyjadrenie je v podobe matematického vzorca za pomoci vy¹¹ie spomínaných operátorov a funckií. Ma» v¹ak v poèítaèi funkciu ulo¾enú ako textový re»azec veµmi komplikuje prácu s òou, preto sa vyvynuli rôzne dal¹ie reprezentácie. Operátory logických funckií sa väè¹inou prevádzajú po rade z $\vee, \wedge, \neg$ na $+, *, !$.

\paragraph{Pravdivostná tabuµka} Najprehµadnej¹í a najµah¹ie nauèiteµný typ uchovávania logickej funkcie, bohu¾ial obsahuje veµké mno¾stvo redundancie a mô¾e ma» veµké pamä»ové nároky ($2^n$, kde $n$ je poèet premenných funkcie).
\paragraph{Logický obvod} Nie moc prehµadný ani µahko nauèiteµný formát, ale vynikajúcí na demo¹tráciu pokroèilých systémov zlo¾ených z logických funkcií.
\paragraph{BDD} Formát v podobe acyklického koreòového grafu, ktorému sa budeme ïalej venova» v kapitole \ref{TypyBDD}.

\subsection{Minimalizácia}
Minimalizácia logickej funkcie je proces zni¾ovania pamä»ových nárokov funkcie odstránením redundancie. V prípade matematického popisu mô¾e ís» o uplatnenie rôznych výrokových teorémov a viet. Podrobnéj minimalizácií BDD sa budeme venova» v kapitole \ref{TypyBDD}.

\subsection{Poèet funkcií}\label{logfce}
Poèet mo¾ných správaní sa logickej funkcie závisí od poètu premenných, ktoré ju ovplyvòujú a poètu hodnôt, ktoré ka¾dá premenná mô¾e nadobudnú». Ide o jednoduchú kombinatoriku, kde zis»ujeme v¹etky variacie vstupných hodnôt, teda $p=n^k$, kde $n$ je poèet hodnôt, ktoré mô¾e nadobúda» vstupná premenná, $k$ poèet vstupných premenných a $p$ je výsedny poèet mo¾ných vstupov funkcie.

Výsledný poèet funkcií je permutácia závisiaca od poètu mo¾ných vstupných kombinácií a poètu hodnôt, ktoré mô¾e nadobúda» výstup funkcie, teda $r=q^p$, kde $p$ je poèet vstupných kombinácií, $q$ je poèet hodnôt, ktoré mô¾e výstpná premenná nadobúda» a $r$ je poèet funkcií danej funkcie. Z tohto dostávame vzorec
\begin{equation}
  r=q^{n^{k}}.
\end{equation}
Názornej¹ie vyjadrenie poètu logických funckií je pomocou tabuµky pre dve vstupné premenné ($k$=2), dve vstupné hodnoty ($n$=2) a dve výstupné hodnoty ($q$=2) $\rightarrow 2^{2^2}=16$ funkcií\\

\begin{center}
  \begin{tabular}{|c|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multicolumn{2}{|c||}{Vstup}&\multicolumn{16}{c|}{Výstup} \\ \hline
    % x & y  \\ \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
    0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ \hline
    1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ \hline
    1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\ \hline
  \end{tabular}
\end{center} 






\chapter{Binárne rozhodovacie diagramy} \label{kap:bdd}
V tejto kapitole popí¹eme históriu BDD, BDD ako matematický formalizmus a transformovanie BDD na redukované usporiadané BDD\,--\,ROBDD.

\section{História}
BDD vznikli z~dôvodu úspornej¹iej reprezentácie logických funckií. Reprezentácia je navrhnutá na základe Shanonovho expazného teorému\cite{Shannon}. Táto dátová ¹truktúra od vzniku v~1959\cite{Lee} pre¹la mnohými úpravami na zní¾enie èasovej a~pamä»ovej nároènosti.

Najvýznamnej¹ím milníkom v~oblasti redukcie pamä»ovej nároènosti bola ¹túdia R. E. Bryanta\cite{Bryant} z~Univerzity Carnegie Mellon. Táto ¹túdia sa týka najmä poradia premenných a~zdieµania podgrafov. Toto sa dá poklada» za vznik ROBDD popísaných v~sekcií \ref{ROBDD}.


\section{Matematický popis}
Prevzaté z predná¹ky \cite{Vojnar}.

BDD je reprezentácia logickej funkcie $\{0,1\}^k\rightarrow\{0,1\},k\geq 0$. Z pohµadu teorie grafov sa jedná o koreòový, orientovaný, spojitý acyklický graf. Formálna definícia BDD $G$ nad mno¾inou premenných $M$ je
\begin{equation} \ref{bdd:formal} 
  G=(N,T,var,low,high,root,val),
\end{equation}
kde 
\begin{itemize}
  \item $N$ je koneèná mno¾ina neterminálnych stavov (uzlov).
  \item $T$ je koneèná mno¾ina terminálnych stavov (listov), $N\cap T=\emptyset$.
  \item $var \colon N\rightarrow M$ je interné pomenovanie uzlov.
  \item $low, high \colon N\rightarrow N\cup T$ funkcia následníkov, definujúca vysokého a nízkeho následníka pre daný úzol $n\in N$ pre premennú $var(n)$ so vstupom $0$ alebo $1$.
  \begin{itemize}
    \item graf je acyklický teda $\neg \exists n \in N.n(low\cup high)^+n$.
  \end{itemize}
  \item $root \in N\cup T$ je koreò grafu, teda $\forall n \in (N\cup T)\backslash\{root\}.root(low\cup high)^+n$. Vstupné hrany do uzlú $root$ by poru¹ili acyklicitu grafu.
  \item $val \colon T\rightarrow \{0,1\}$ je mapovacia funkcia hodnôt terminálnych uzlov
\end{itemize}

\section{Procedúra \emph{Apply()}} \label{apply}
Procedúra \emph{Apply()} aplikuje booleovskú funkciu na BDD. Mô¾e by» unárna, alebo binárna, výnimoène ternárna. Procedúre sú predané v¹etky BDD s ktorými pracuje a odkaz na funkciu, ktorú má vykona». Poèet funkcií je odvodený v kapitole \ref{logfce}. Výsledkom procedúry je jedno BDD.

Princíp práce funkcie je rekurzívny zostup od koreòa a¾ k terminálnym uzlom. Keï sa funkcia nachádza v bode, ¾e pre oba stromy pre¹la rovnakú cestu a v oboch stromoch sa nachádza na terminálnom uzle, zapí¹e sa táto cesta do nového stromu a novému terminálnemu uzlu sa priradí hodnota výsledku po¾adovanej logickej funkcie nad dvoma pôvodnými terminálnymi uzlami. 


\section{Typy BDD}\label{TypyBDD}
V tejto kapitole si popí¹eme niektoré základné typy BDD, zdôrazníme rozdiely medzi nimi a objasníme, v èom sú niektoré efektívnej¹ie ako iné. Základné princípy budeme demon¹trova» na funkcii

\begin{equation}
  f(x_1,x_2,x_3)=(\neg x_1\wedge \neg x_2 \wedge \neg x_3)\vee(x_1\wedge \neg x_2\wedge \neg x_3)\vee(x_1\wedge x_2\wedge \neg x_3).
\end{equation}

V texte budeme pou¾íva» nasledujúcu notáciu
\begin{itemize}
  \item Premenné sa znaèia $x_i$, kde $i$ je poradie premennej.
  \item Uzly sa znaèia písmenom $n_{ij}$, kde $i$ je index premennej a $j$ je poradové èíslo uzlu oznaèovaného premennou.
\end{itemize}
Príklad: $n_{23}$ znaèí tretí uzol premennéj $x_2$.


\section{BDT}\label{ROBDD}
Binárny rozhodovací strom sa vytvára ako koreòový graf. Koreò tvorí jedna z premenných, väè¹inou sa berie prvá premenná funkcie, teda v na¹om prípade $x_1$. Vytvoríme teda uzol $n_{11}$, ktorý je mapovaný na premennú $x_1$. Premenná mô¾e nadobúda» dvoch hodnôt, pre ktoré sú definované nasledujúce uzly mapované na nasledujúcu premennú (uzly $n_{21}$ a $n_{22}$ mapované na premennú $x_2$). Takto sa postupne zanorujeme, a¾ prejdeme cez v¹etky premenné a vygenerujeme v¹etky potrebné uzly. Hodnoty priradené za uzly mapované na poslednú premennú sú terminálne uzly. Poèet generovaných uzlov je 
\begin{equation} \label{pocetUzlov}
  \sum_{i=0}^{k} 2^i,
\end{equation}
kde $k$ je poèet premenných.

Grafické znázornenie na¹ej funkcie je na obrázku \ref{picBDD}.
\begin{figure}[ht!]
  \includegraphics[bb=0 50 0 200]{fig/bdd1.eps}
  \caption{Základné BDD}
  \label{picBDD}
\end{figure}

\paragraph{Notácia}
Pre orientáciu v grafe je pou¾itá nasledujúca notácia
\begin{enumerate}
  \item Uzly
    \begin{itemize}
      \item Znaèené krú¾kom.
      \item Hierarchicky usporiadané podµa poradia vyhodnocovania.
      \item Premenná ovplyvòujúca uzol je písaná vµavo.
    \end{itemize}
  \item Terminály
    \begin{itemize}
      \item Znaèené ¹tvorèekom.
      \item Symbol $\perp$ znaèí hodnotu $false$.
      \item Symbol $\top$ znaèí hodnotu $true$.
    \end{itemize}
  \item Hrany
    \begin{itemize}
      \item Plná èiara vedie k vysokému následníkovi daného uzlu $high(n)$.
      \item Preru¹ovaná èiara vedie k nízkemu následníkovi daného uzlu $low(n)$.
    \end{itemize}
\end{enumerate}

Ako vidíme, pre 3 premenné je poèet generovaných uzlov 15, èo je exponencialna zlo¾itos», èím je potvrdená rovnica \ref{pocetUzlov}. Zlo¾itos» najdenia daného terminálneho uzlu je lineárna vzhµadom k poètu premenných. Táto reprezentácia obsahuje mnoho redundancie, preto sa nepou¾íva.

\subsection{Redukované BDD}
Poèet generovaných uzlov sa dá výrazne obmedzi» tým, ¾e sa nebudú generova» zbytoèné uzly. Pri pohµade na obrázok \ref{picBDD} vidíme redundanciu v terminálnych uzloch. Terminálne uzly mô¾eme zlúèi» do dvoch. Vzniká diagram s redukovaným poètom terminálnych uzlov, ktorý je znázornený na obrázku \ref{picRBDD1}.

\begin{figure}[ht!]
  \includegraphics[bb=0 0 0 200]{fig/bdd2.eps}
  \caption{BDD s redukovaným poètom terminálnych uzlov}
  \label{picRBDD1}
\end{figure}

Ïal¹iou redukciou je zluèovanie izomorfných podgrafov. Keï sa v BDD nachádzajú dva rôzne uzly, ktoré majú rovnaké (izomorfné) podgrafy, mô¾eme ich zlúèi» do jedného.

\paragraph{Graf} je definovaný ako dvojica $G=(V,H)$, kde $V$ je mno¾ina vrcholov a $H$ je mno¾ina hrán typu $(v_1,v_2)$ kde $v_1,v_2 \in V$, teda $H\subseteq V^2$.
\paragraph{Izomorfizmus} dvoch grafov $G_1=(V_1,H_1)$ a $G_2=(V_2,H_2)$ je definovaný vzájomne bijektívne zobrazenie $f:V_1\rightarrow V_2$ a $g:H_1\rightarrow H_2$ také, ¾e µubovoµnej hrane $h\in H_1$ sú priradené vrcholy $x,y\in V_1 \Leftrightarrow$ hrane $g(h)\in H_2$ sú priradené vrcholy $f(x),f(x)\in V_2$.\\Pokiaµ grafy $G_1$ a $G_2$ sú izomorfné, teda existujú funkcie $f$ a $g$, potom pí¹eme $G_1 \otimes G_2$.

Strom s odstránenými izomorfnými podstromamy je na obrázku \ref{picRBDD2}.

\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd3.eps}
  \caption{BDD s odstránenými izomorfnými podstromami}
  \label{picRBDD2}
\end{figure} 

Ïal¹iou redukciou je vynechávanie uzlov, kde $low(n) = high(n),pre\ n\in N$. Ak sa vysoký aj nízky následník odkazujú na izomorfné podgrafy, logická funkcia v tomto bode nezávisí od danej premennéj, preto sa mô¾e tento uzol vynecha». Výsledný strom je na obrázku \ref{picRBDD3}.

\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd4.eps}
  \caption{Výsledné minimalizované BDD}
  \label{picRBDD3}
\end{figure}

\paragraph{RBDD} je klasické BDD, pre ktoré platia nasledujúce pravidlá:
\begin{enumerate}
  \item $\neg\exists n\in N.low(n)=high(n)$
  \item $\neg\exists x_1,x_2\in N \cup T.x_1=x_2\wedge Root(G_1)=x_1\wedge root(G_2)=x_2 \wedge G_1 \otimes G_2$
\end{enumerate}


\subsection{Redukované usporiadané BDD} 
Poradia vyhodnocovania premenných, ktoré ovplyvòujú uzly, majú veµký vplyv na poèet generovaných uzlov. Pre ilustráciu si to predveïme na funkcií
\begin{equation}
  y(x_1,...,x_8) = (x_1 \wedge x_2)\vee(x_3 \wedge x_4)\vee(x_5 \wedge x_6)\vee(x_7 \wedge x_8).
\end{equation}
RBDD odpovedajúce danej funkcie je na obrázku \ref{picROBDD}.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=150mm]{fig/bdd5.jpg}
  \caption{Rozdiel medzi dobrým a zlým usporiadaním\cite{WikiOrder}}
  \label{picROBDD}
\end{figure}
\par
Obe BDD sú minimalizované a popisujú rovnakú logickú funckiu. Z pravého obrázku v¹ak vidíme, ¾e dobrým usporiadaním výrazne zní¾ime poèet generovaných uzlov. Na zistenia optimálneho usporiadania v¹ak neexistuje doposiaµ ¾iadný efektívny algoritmus. Jedná sa o NP-nároèný problém. Existujú iba rôzne heuristiky. Tie nám v¹ak mô¾u pomôc», teda dostaneme výsledný strom s men¹ím poètom uzlom, ale aj u¹kodi». Tu je zoznam niektorých pou¾ívaných algoritmov:

%BDD-dip
\textbf{Náhodný algoritmus}\cite{Rucky} Algoritmus sa pou¾íva v dvoch variantách a to varianta s pivotom a varianta bez pivota.\\Varianta bez pivota vyberá dve náhodné premenné v grafe a tie vymení postupným vymieòaním susedných uzlov. Výsledné usporiadanie premenných pre danú iteráciu je ulo¾enie s najmen¹ím poètom uzlov v priebehu itérácie. \\ Varianta s pivotom pracuje na rovnakom princípe, ale pred samotným algoritmom sa vyberie pivot. To je premenná s najvy¹¹ím poètom uzlov. Dve náhodne zvolené premenné sú také, ¾e jedna sa nachádza nad a druhá pod pivotom. 

\textbf{Sifting algoritmus} \cite{Rudell} Teória je spoèíta» najvýhodnej¹iu pozíciu v grafe pre jednu premennú s tým, ¾e ostatné premenné zachovajú svoje poradie. Premennú posúvame najskôr smerom k terminálnym uzlom, potom smerom ku koreòu. Po príchode do koreòu vieme, v ktorej pozícií mala premenná najmenej uzlov a posunieme ju tam. Posun sa vykonáva na základe prehadzovania susedných premenných.

Iné pou¾ívané algoritmy sú napríklad
\begin{itemize}
  \item{Symmetric sifting algoritmus}
  \item{Group sifting algoritmus}
  \item{Window permutation algoritmus}
  \item{Algoritmus vyu¾ívajúci genetické algoritmy}
\end{itemize}

\section{Multiterminálne BDD}
Formálna definácia MTBDD je rovnaká ako definiícia \ref{bdd:formal} pre BDD s rozdielom, ¾e v MTBDD mno¾inu $\mathit{val}$ definujeme takto:
\begin{itemize}
  \item $\mathit{val} \colon T \rightarrow \mathds{D}$, kde $\mathds{D}$ je potenciálne nekoneèná mno¾ina.
\end{itemize}

Multiterminálne BDD sú vo svojej podstate obyèajné ROBDD, ktoré majú väè¹í, obecne neobmedzený poèet terminálnych uzlov. Ako príklad si mô¾eme uvies» kombinaèný systém\footnote{Stav závisí iba na kombinácii vstupu}, ktorý sa mô¾e nachádza» v stavoch $S_{\mathit{off}}$, $S_{set}$ a $S_{count}$. Vstupné premenné sú $X_{on}$ a $X_{count}$. Tabuµka systému je 
\begin{center}
  \begin{tabular}{|c|c||c|}
    \hline
    $X_{on}$ & $X_{count}$ & $S(X_{on}, X_{count})$ \\ \hline
    0 & 0 & $S_{\mathit{off}}$ \\ \hline
    0 & 1 & $S_{\mathit{off}}$ \\ \hline
    1 & 0 & $S_{set}$ \\ \hline
    1 & 1 & $S_{count}$ \\ \hline
  \end{tabular}
\end{center}

Na miminalizáciu MTBDD sa dajú pou¾i» opä» pou¾i» obe techniky, teda odstránenie izomorfných podstromov a uzlov, kde $\mathit{high}(x)=\mathit{low}(x)$. Podµa tabuµky jednoducho zostrojíme a zminimalizujeme BDD, ktoré v¹ak nemá iba 2 terminálne hodnoty ale 3. 

\begin{figure}[ht!]
  \includegraphics[bb=-100 0 0 250]{fig/bdd6.eps}
  \caption{Príklad MTBDD}
  \label{picMTBDD}
\end{figure}



  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Porovnání dostupných programových balíkù pro manipulaci
% s binárními rozhodovacími diagramy, Martin Felcman, BP, 2008
% felcmm1_2008bach.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dostupné balíky} \label{kap:baliky} 
V tejto kapitole si popí¹eme niektoré kni¾nice pracujúce s BDD. Bude popísaná ¹truktúra uzlu a spôsob práce s diagramami.

\section{CUDD}
Balíèek bol vyvíjaný na univerzite v Coloradu. U¾ od roku 1996 stálym vývojom dosiahol vynikajúce pamä»ové a výkonnostné výsledky. Podporuje prácu s BDD, Aritmetickými rozhodovacími diagramami ADD a diagramami s potlaèenou nulou ZDD. V kni¾nici je taktie¾ implementovaná sada algoritmov na zlep¹enie usporiadania premenných. Balíèek sa mô¾e pou¾íva» 3 spôsobmi:
\begin{enumerate}
  \item {Black box}\,--\,Umo¾òuje pou¾íva» iba exportované funkcie popísané v nápovede.
  \item {Clean box}\,--\,Umo¾nuje písanie zlo¾itej¹ích projektov, kde je vzhµadom k efektivite nutné prida» do balíka vlastné funkcie.
  \item {Interface}\,--\,Balík disponuje kvalitne spracovaním rozhraním pre prácu s BDD ako objektami.
\end{enumerate}
Podrobná definícia celého balíka CUDD je popísaná v literatúre\cite{cudd}.

\subsection{©truktúra uzlu}
\begin{lstlisting}
struct DdNode{
  DdHalfWord index;
  DdHalfWord ref;
  DdNode *next;
  union{
    CUDD_VALUE_TYPE value;
    DdChildren kids;
  } type;
};
\end{lstlisting}
©truktúra reprezentuje terminálne aj neterminálne uzly. Na zistenie, èi konkrétny uzol je terminálny slú¾i makro \texttt{Cudd\_IsConstant()}. V premennej \texttt{index} je ulo¾ený názov premennej, podµa ktorej je pomenovaný uzol. Odrá¾a poradie vzniku uzlov. V premennej \texttt{ref} je poèítadlo referencií na uzol. Premenná \texttt{next} ukazuje na daµ¹í uzol v unique table. Ak ide o terminálny uzol, obsahuje premennú \texttt{value}, ktorá znaèí hodnotu uzlu, ináè obsahuje ¹truktúru \texttt{kids}, kde sú ulo¾ené ukazatele na vysokého a nízkeho následníka daného uzlu. 

\subsection{Manager}
V¹etky pou¾ité uzly sú ulo¾ené v ¹pecialnej hashovaciej tabuµke (unique table). BDD a ADD zdieµajú rovnakú tabuµku, ZDD má svoju vlastnú. Manager sa pred pou¾itím inicializuje funkciou \texttt{Cudd\_Init()} a po pou¾ití ru¹í funckiou \texttt{Cudd\_Quit()}.

\subsection{Zhrnutie}
CUDD je univerzálny balíèek pre prácu s BDD. Má kvalitne spracovanú dokumentáciu vèetne u¾ivateµského a programátorského manuálu. Výhodou je disponovanie ¹irokou ¹kálou funkcií pre radenie poradia premenných. 



\section{BuDDy}
Táto kni¾nica bola vytvorená ako súèas» dizertaènej práce. Spoèiatku bola urèená len na demo¹tráciu princípov BDD. Vo svojej poslednej verzií je u¾ v¹ak plnohodnotným balíkom so v¹etkými ¹tandartnými operáciami, radením poradia premenných a dokumentáciou.

\subsection{©truktúra uzlu}
\begin{lstlisting}
typedef struct s_BddNode{
  unsigned int refcou : 10;
  unsigned int level : 22;
  int low;
  int high;
  int hash;
  int next;
} BddNode;
\end{lstlisting}

Je potrebné uvies», ¾e BuDDy nepracuje s managerom ale s poµom uzlov, preto v¹etky premenné, ktoré odkazujú nejaký uzol sú reprezentované ako index do tohto poµa.

Premenná \texttt{refcou} obsahuje poèet referencií vedúcich na uzol. Premenná \texttt{level} ukazuje pozíciu premennéj pri súèastnom ulo¾ení. Premenné \texttt{high} a \texttt{low} reprezentujú hrany, \texttt{next} je ukazateµ na nasledujúci uzol. Premenná \texttt{hash} je ukazateµ na koreò stromu.
\\
\subsection{Zhrnutie}
BuDDy je kompletný balík na prácu s BDD. Podporuje usporiadavanie premenných. BuDDy má veµmi kvalitne spracované C\verb!++! rozhranie, ktoré zefektívòuje prácu s týmto balíkom.


\section{CacBDD}
Jedná sa o kni¾nicu vyvýjanú v jazyku C\verb!++!, ktorá je podobne ako BuDDy zalo¾ená na indexovaní v poli. Podporuje obvyklé operátory vyu¾ívané v modelcheckingu. CacBDD má kvalitne spracované ukµadanie medzivýsledkov, vïaka èomu dosahuje výborné èasové výsledky.

Kni¾nica je veµmi jednoducho popísaná v literatúre\cite{cacbdd}. Ja som potrebné informácie nachádzal priamo v zdrojových súboroch dostupných z \url{http://www.kailesu.net/CacBDD/CacBDD.zip}.

\subsection{©truktúra uzlu}
\begin{lstlisting}
class DdNode{
  public:
    int var;     
    int Then;
    int Else;
    int Next;
    
    // metody
}
\end{lstlisting}

Jeden uzol je ulo¾ený v triede \texttt{DdNode}. 






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Návrh implementácie}
V tejto kapitole popí¹em svôj návrh implementácie jednotlivých dátových ¹truktúr a algoritmov.
Popí¹em taktie¾ problémy ktoré som mal poèas implementácie.
\section{Dátové ¹truktúry}
Èas» vysvetluje popis implementácie a prepojenia jednotlivých dátových ¹truktúr.
\subsection{BDD uzol}\label{tBddNode}
Základnou jednotkou ka¾dého diagramu je uzol. Môj návrh uzlu obsahuje v¹etky
dôle¾ité premenné pre úplnu prácu s ním.
\begin{lstlisting}
typedef struct BddNode{
  struct BddNode *high, *low;
  unsigned int var;
  unsigned int ref;
  struct BddNode *nextFree;
}tBddNode;
\end{lstlisting}
Premenné \texttt{high} a \texttt{low} sú ukazatele na vysokého a nízkeho následníka uzlu. V prípade, ¾e ide 
o terminálny uzol, \texttt{high} a \texttt{low} sú nastavené na \texttt{NULL}. Na zistenie, èi je daný uzol
terminálny sa pou¾íva makro \texttt{isTerminal(t)}. Premenná \texttt{var} je index do tabuµky návestí premenných, 
o ktorej si viac povieme v sekcií \ref{tLabels}. Premenné \texttt{ref} a \texttt{nextFree} sú premenné, ktoré 
vyu¾íva garbage collector. \texttt{ref} je poèítadlo referencií, ktoré je dôle¾ité pri zdielaných uzloch 
a \texttt{nextFree} je ukazateµ, ktorý previazáva zoznam voµných premenných ktoré má k dispozícií manager. 
Viac v kapitole \ref{tManager}.

\subsection{Garbage collector}\label{tGarbage}
Garbage collector má jednoduchú ¹truktúru.
\begin{lstlisting}
typedef struct Garbage{
  tBddNode *nodes;
  struct Garbage *next;
}tGarbage;
\end{lstlisting}
Premenná \texttt{nodes} ukazuje na pole v¹etkých uzlov a premenná \texttt{next} na pola ïal¹ieho kusu pamäti,
ktorý sa alokuje v prípade, ¾e manager nemá voµné uzly.

\subsection{Návestia premenných} \label{tLabels}
Je indexované pole re»azcov. ©truktúra je taktie¾ veµmi jednoduchá.
\begin{lstlisting}
typedef struct Labels{
  char **lab;
  unsigned int count;
}tLabels;
\end{lstlisting}
Premenná \texttt{lab} je odkaz na pole re»azcov\footnote{Re»azcom je myslený typ \texttt{char *}.} a \texttt{count} 
je premenná oznaèujúca poèet re»azcov, pou¾ívana hlavne pri realokácií prvej úrovne \texttt{lab}.

\subsection{Medzivýsledky\,--\,\emph{Cache}} \label{tCache}
Medzivýsledkami sa rozumejú nacachované uzly, ktoré zni¾ujú pamä»ovú zlo¾itos» a veµmi zjednodu¹ujú
zdielanie podgrafov. ©truktúra je nasledujúca.
\begin{lstlisting}
typedef struct Cache{
  unsigned int var;
  tBddNode *high, *low, *record;
  struct Cache * next;
} tCache;
\end{lstlisting}
©truktúra Cache je zoznam, ktorého previazanie zais»uje premenná \texttt{next}. 
Ulo¾ené uzly sa cacheujú ako trojica $[\mathit{var},\mathit{high},\mathit{low}]$.
Záznamy ¹truktúry Cache tomu odpovedajú. Pri prehµadávaní cache sa sa táto trojica
porovnáva s trojicou uzlu, ktorý kontrolujeme. V prípade zhody premenná \texttt{record}
obsahuje ukazateµ na u¾ vytvorený uzol.

\subsection{BDD manager}\label{tManager}
Zastre¹ujúca ¹truktúra, riadiaca celú tvorbu a úpravy BDD.
\begin{lstlisting}
typedef struct Manager{
  tGarbage *nodes;
  tBddNode *free;
  tLabels *variables;
  tLabels *terminals;
  tCache *cache;
}tManager;
\end{lstlisting}
\texttt{nodes} je ukazateµ na ¹truktúru garbage collectoru, ktorá ma nastarosti uvoµnovanie a vytváranie nových
zhlukov uzlov. \texttt{free} je ukazateµ na prvý voµný uzol. Ide opä» o zoznamovú implementáciu, kde sú v¹etky
uzly prepojené pomocou \texttt{nextFree}, viz \ref{tBddNode}. \texttt{cache} je zoznam nacachovaných uzlov.
\texttt{variables} a \texttt{terminals} sú návestia uzlov.
\subsection{Chyby}
Enumerácia v¹etkych chybových stavov balíka a odpovedajúce správy pre u¾ivateµa pomocou makra \texttt{throwError(e)}.

\section{Algoritmy}
Hlavné u¾ivateµské rozhranie tvoria funkcie \texttt{bddInit()}, ktorá inicializuje v¹etky komponenty pre manager,
\texttt{bddDestroy()}, ktorá uvoµnuje v¹etky prostriedky, ktoré daný manager alokoval, \texttt{bddCreateNode()} 
a \texttt{bddCreateTerminal()}, ktoré vytvoria uzol pre danú premennú alebo terminál a funkcia
\texttt{bddApply()}.
\subsection{Inicializácia}
®iadnu z operácií nie je mo¾né prevádza» nad neinicializovaným managerom. Na inicializáciu slú¾i funkcia
\texttt{bddInit()}, ktorá postupne inicializuje v¹etky prvky ¹truktúry. Najdôle¾itej¹iu èas»ou je inicializácia
premennej \texttt{nodes}, ktorá vytvorí pole uzlov podµa zadanej veµkosti. V¹etky tieto uzly sú prístupné 
zo zoznamu v premennej \texttt{free}. Automaticky sa generujú dva uzly \texttt{bddFalse} a \texttt{bddTrue}
prístupné na globálnej úrovni.
\par
Inicializáciu zvy¹ných komponent tvorí zväè¹a nastavenie ukazateµa aktívnej èasti ¹truktúry na \texttt{NULL}.
\subsection{Uvolòovanie}
Na uvolnenie slú¾i funkcia \texttt{bddDestroy()}, ktorá postupne zru¹í v¹etky alokované ¹truktúry.
Je neprípustné ukonèi» program pred zavolaním tejto funkcie, preto ¾e by dochádzalo k únikom pamäti\footnote{
Memory leak je blok pamäti príslu¹iaci ukonèenému programu.}.
\par
Postupne sa uvolòujú prostriedky garbage collectora, tj. zru¹ia sa uzly a potom sa dealokuje ¹truktúra.
Je potreba dáva» pozor na to, ¾e garbage collector je v podsate zoznam, teda je potrebné ho uvolni»
korektne celý a nie iba prvý blok pamäti. Cache tvorí taktie¾ zoznam, preto sa musí uvolòova» postupne.
Uvolnenie ¹truktúry návestí je iba volanie funkcie \texttt{free()} nad premennou ¹truktúry \texttt{lab}.
Ïalej sa u¾ uvolòuje iba samotná ¹truktúra.
\subsection{Vytvorenie uzlu}
Na vytváranie uzlov sa pou¾íva funkcia \texttt{bddCreateNode()}. Funckia ukladá návestie vytváraného
uzlu do premennej manager \texttt{variables}. V uzle sa nastavia v¹etky jeho informácie a to takto:
\begin{enumerate}
  \item nastavíme premennú \texttt{var} na index v tabuµke \texttt{variables}
  \item poèítadlo referencií \texttt{ref} nastavíme na 1
  \item oznaèíme uzol ako pou¾ívaný nastavením \texttt{nextFree} na \texttt{NULL}
  \item vysokému následníkovi \texttt{high} priradíme \texttt{bddTrue}
  \item nízkemu následníkovi \texttt{low} priradíme \texttt{bddFalse}
  \item pozrieme do cache, èi u¾ takýto uzol neexistuje a vraciame ukazateµ
\end{enumerate}
V prípade nového terminálneho uzla sa pou¾íva funkcia \texttt{bddCreateTerminal()}.
Sú tu iba nepatrné zmeny:
\begin{itemize}
  \item návestie sa vkladá do tabuµky \texttt{terminals}
  \item referencie sa na terminálnych uzloch nepoèítajú
  \item do \texttt{high} a \texttt{low} priradíme \texttt{NULL}
\end{itemize}
Vytváranie MTBDD je vo svojej podstate rovnaké ako vytváranie obyèajného BDD s rozdielom,
¾e na vytvorenie uzlu sa pou¾íva funkcia \texttt{mtbddCreateNode()}. Tá okrem ¹tandartných
parametrov funkcie \texttt{bddCreateNode()} príjma aj ukazatele na následníkov. 

\subsection{Práca s mezdivýsledkami\,--\,\emph{Cacheovanie}}
Ka¾dý vytvorený uzol (s výnimkou terminálnych) sa ukladá do ¹truktúry uvedenej
v èasti \ref{tCache}. Ukladajú sa ako trojica vysokého následníka, nízkeho následníka
a návestia premennej. Pri vytváraní uzlu sa uzol najskôr vytvorí, potom sa pozrie do
cache pomocou funkcie \texttt{cacheCheck()}. Ak daný uzol u¾ existuje, funkcia vracia ukazateµ
na uzol. Pôvodne vytvorený uzol sa ru¹í a ako výsledok sa vracia uzol ukazujúci na 
u¾ existujúci uzol, ktorého ukazateµ sme vytiahli z cache. V prípade ¾e uzol e¹te neexistuje,
vytvára sa nový cache záznam pomocou funkcie \texttt{cacheInsert()}, ktorá na zaèiatok
zoznamu pridáva daný uzol. V prípade, ¾e poèítadlo referencií \texttt{ref} nejakého uzlu
padne na nulu, uzol je uvoµnený a cache záznam zru¹ený.
\subsection{Procedúra \emph{Apply()}}
Základný princíp procedúry bol u¾ popísaný v èasti \ref{apply}. Implementáciu v kni¾nici
tvoria dve funkcie. Prvá je \texttt{bddApply()}, ktorá sa volá z u¾ivateµského programu.
Ako parameter dostáva dva ukazatele na diagramy (typ \texttt{tBddNode $*$}), manager, 
v ktorom sa má procedúra vykona» (typ \texttt{tManager $*$}) a odkaz na funkciu
vracajúcu nový diagram (typ \texttt{tBddNode $*(*)()$}). Funkcia spú¹»a rekurzívnu
funkciu \texttt{\_apply()} s rovnakými parametrami. \texttt{\_apply()} sa rekurzívne
zanoruje podµa algoritmu \ref{algApply}.
\begin{algorithm}[h]
  \caption{\_apply} \label{algApply}
  \SetAlgoLongEnd
  \LinesNumbered
  \SetNlSty{normal}{}{:}
 
  \KwIn{$X,Y,\mathit{func}$}
  \KwOut{$\mathit{result}$}
\medskip
  \eIf{($X$ aj $Y$ sú terminály)}{
    \Return $\mathit{func}(X,Y)$ \;
  }{
    \eIf{($X$ je nad $Y$)}{
      vytvor uzol podµa $\mathit{var}_X$\;
      zanor $X$\;
    }{
      \eIf{($Y$ je nad $X$)}{
        vytvor uzol podµa $\mathit{var}_Y$\;
        zanor $Y$\;
      }{
        vytvor uzol podµa jednej z premenných\;
        zanor obe premenné\;
      }
    }
  }
  $\mathit{result}=\mathit{\_apply(X,Y,\mathit{func})}$\;
  \medskip
  \eIf{$(\mathit{low_{result}=high_{result}})$}{
    $\mathit{result=low_{result}}$\;
  }{
    \If{$(\mathit{result}$ je v $\mathit{cache})$}{
      uvolni $\mathit{result}$\;
      \Return cacheovaný záznam\;
    }
  }
  \medskip
  \Return $\mathit{result}$\;
\end{algorithm}

Pri vytváraní nových uzlov v procedúre sa pou¾íva funkcia \texttt{bddNewNode()},
ktorá má rovnaké správanie ako \texttt{bddCreateNode()} s rozdielom, ¾e nekontroluje
cache. Cache sa kontroluje a¾ na konci procedúry spolu s kontrolovaním, èi potomkovia
nie sú rovnakí.
\par
Kni¾nica disponuje základnými logickými funkciami, ktoré mô¾u by» ako parameter funkcie
\texttt{bddApply()}. Tieto funkcie sú \texttt{bddOr()}, \texttt{bddNor()}, \texttt{bddAnd()},
\texttt{bddNand()}, \texttt{bddXor()} a \texttt{bddNeg()}. Funkcia \texttt{bddNeg()}, sa prakticky
nikdy nezavolá, lebo vo funckií \texttt{bddApply()} sa funkcia \texttt{bddNeg()} transformuje
na funkciu \texttt{bddNand()} a ako korene oboch diagramov sa predá rovnaký ukazateµ.
\par
Za zmienku tie¾ stojí, ¾e funkcia \texttt{bddApply()} znièí ukazatele predané ako parameter.
je to spôsobené tým, ¾e procedúra nemodifikuje BDD, ale vytvára úplne nové.

\subsection{Práca s MTBDD}
Ako bolo u¾ vy¹¹ie spomínané, kni¾nica pracuje na globálnej úrovni kvôli premenným
\texttt{bddTrue} a \texttt{bddFalse}. Balík taktie¾ disponuje mno¾inou základných
operácií nad binárnymi premennými. Pri práci s MTBDD u¾ivateµ vytvára vlastné terminálne
uzly na globálnej úrovni a vlastné funkcie pre prácu s týmito uzlami.
\par
Je dôle¾ité poznamena», ¾e pri práci s MTBDD je veµmi dôle¾itou èas zvládnu» návrh prechodovej
funkcie systému.

\subsection{Uká¾ky kódov}
Predvedieme si niektoré kon¹trukcie, ktoré sa vyu¾ívajú na tvorbu rozhodovacích diagramov.
\subsubsection{Jednoduchá binárna funkcia}
Nasledujúci kód vytvorí funkciu 
$$f(a,b,c) = (a\wedge b) \vee (\neg a\wedge c)$$

\begin{lstlisting}
#include"bdd.h"

int main(){
  tError e;
  tManager manager;
  tBddNode *a,*b,*c;

  e = bddInit(&manager,BDD_SMALL);
  if(e) bddThrowError(e);
  
  bddCreateNode(&manager,"A",&a);       // A
  bddCreateNode(&manager,"B",&b);       // B
  b = bddApply(&manager,b,NULL,bddNeg); // !B
  a = bddApply(&manager,a,b,bddAnd);    // (A * !B)
  
  bddCreateNode(&manager,"C",&c);       // C
  bddCreateNode(&manager,"D",&b);       // D
  c = bddApply(&manager,c,b,bddAnd);    // (C * D)

  a = bddApply(&manager,a,c,bddOr);     // (A * !B) + (C * D)

  printTree(&manager,a);

  bddDestroy(&manager);
  return 0;
}
\end{lstlisting}
V kóde si mô¾eme v¹imnú», ¾e niektoré ukazatele pou¾ívame viac krát. Je to z dôvodu, ¾e BDD
predané ako parametre funkcie \texttt{bddApply} sú uvoµnené.
\subsubsection{Práca s MTBDD}
Práca s MTBDD je o nieèo málo zlo¾itej¹ia pri koncepcií. Pre jednoduchos» som zvolil uká¾ku 
vytvorenia MTBDD popísaného na obrázku \ref{picMTBDD}. Dôle¾itá je správna analýza systému.
Je potrebné vytvori» nové terminálne uzly, ktoré vytvoríme pomocou funckie
\texttt{bbdCreateTerminal()}. Ïalej zostrojíme tabuµku výsledných stavov uplatnenia funkcie
na jednotlivé terminály. Tabuµka je nasledujúca
\begin{center}
\begin{tabular}{|c|c c c|}
\hline
$\mathit{func}(x,y)$ & $\mathit{S_{off}}$ & $\mathit{S_{set}}$   & $\mathit{S_{count}}$  \\ 
\hline
$\mathit{S_{off}}$   & $\mathit{S_{off}}$ & $\mathit{S_{off}}$   & $\mathit{S_{off}}$  \\ 
$\mathit{S_{set}}$   & $\mathit{S_{off}}$ & $\mathit{S_{set}}$   & $\mathit{S_{count}}$  \\ 
$\mathit{S_{count}}$ & $\mathit{S_{off}}$ & $\mathit{S_{count}}$ & $\mathit{S_{count}}$  \\ \hline
\end{tabular}
\end{center}
Tabuµka zna¾í prechodovú funckiu ná¹ho systému. Implementácia pomocou kni¾nice je nasledujúca
\begin{lstlisting}
#include"bdd.h"

// vytvorenie terminalov na globalnej urovni
tBddNode * Soff;
tBddNode * Sset;
tBddNode * Scount;

// prechodova funkcia systemu
tBddNode * func(tBddNode * x, tBddNode * y) {
  if(x == y) return x;
  if(x == Soff || y == Soff) return Soff;
  return Scount;
}

int main(){
  tError e;
  tManager manager;
  tBddNode *a,*b;

  e = bddInit(&manager,BDD_SMALL);
  if(e) bddThrowError(e);
  
  // inicializacia terminalov
  bddCreateTerminal(&manager,"S_off",&Soff);
  bddCreateTerminal(&manager,"S_set",&Sset);
  bddCreateTerminal(&manager,"S_count",&Scount);
  
  // vytvorenie uzlov
  mtbddCreateNode(&manager,"X_on_off",Sset,Soff,&a);
  mtbddCreateNode(&manager,"X_set_count",Sset,Scount,&b);

  // aplikacia funkcie
  a = bddApply(&manager,a,b,func);
  
  printTree(&manager,a);

  bddDestroy(&manager);
  return 0;
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Testy}
\section{Memory leaks}
\section{Rýchlos» vyhµadania uzlu}
\section{Rýchlos» procedúry \emph{Apply()} }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\chapter{Porovnanie s kni¾nicami CUDD a VATA}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závìr}

