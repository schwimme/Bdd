\chapter{Úvod}
V~mnohých oblastiach informatiky je potrebné efektívne pracova» s~funkciami nad binárnimi premennými. Mô¾e ís» napríklad o~efektívnu reprezentáciu hardwarových komponént pri návrhu logických obvodov, reprezentáciu veµkých matíc v~matematických knihovniach alebo o~efektívnu reprezentáciu stavového priestoru vo formálnej verifikácií. Existuje niekoµko prístupov pre repzrezentáciu týchto funkcií, prièom jedným z~najpou¾ívanej¹ích sú binárne rozhodovacie diagramy (BDD).

BDD reprezentuje funkciu nad binárnimi premennými kompaktne pomocou koreòového acyklického orientovaného spojitého grafu. Nad týmto grafom sa dajú uplatòova» rôzne algoritmy, ktoré zni¾ujú jeho pamä»ovú aj èasovú nároènos».

BDD majú neiktoré vlastosti, ktoré ho robia vhodnými kandidátmi na uplatnenie v~uvedených oblastiach ako to napríklad reprezentácia viacerých funckií iba jedným BDD, operácie nad kompaktným ulo¾ím a~mnoho iných.

Úèelom práce je navrhnú» a~implementova» vlastnú kni¾nicu pre prácu s~BDD. Práca demon¹truje základné princípy algoritmov uplatnených nad BDD, mo¾nosti reprezentácie BDD v~poèítaèi a~súèas»ou je taktie¾ porovnanie dosiahnutých výsledkov s~kni¾nicou CUDD.

Práca obsahuje v~kapitole~\ref{kap:logika} formálny popis výrokovej logiky, v~kapitole~\ref{kap:bdd} typy BDD, prevod binárneho rozhodovacieho stromu BDT na BDD, základný princíp procedúry apply a~popis MTBDD. V~kapitole~\ref{kap:baliky} popí¹eme niektoré existujúce balíky pre prácu s~BDD a~MTBDD. Zvy¹ná èas» práce obsahuje popis návrhu, implementácie a~testovania kni¾nice. Záver práce patrí zrovnaniu výsledkov s~kni¾nicou CUDD.





\chapter{Výroková logika} \label{kap:logika}

Výroková logika skúma spôsoby tvorby zlo¾ených výrokov z~jednoduchých a~pravdivos» (nepravdivos») zlo¾eného výroku v~závislosti od pravdivosti jednoduchých, z~ktorých je zlo¾ený. Celá kapitola o~výrokovej logike je prevzaná z~\cite{Slapal}.

Buï $P$ neprázdna mno¾ina prvotných formúl, ktoré hrajú úlohu jednoduchých výrokov. Z~jednoduchých výrokov získaváme zlo¾ené výroky spájaním pomocou logických spojok. Poznáme nasledujúce logické spojky:
\begin{itemize}
  \item{$\neg$ negácia}
  \item{$\vee$ disjunkcia}
  \item{$\wedge$ konjunkcia}
  \item{$\rightarrow$ implikácia}
  \item{$\equiv$ ekvivalencia}
\end{itemize}

Symbolmi jazyka $L_P$ výrokovej logiky nad mno¾inou $P$ sú prvky mno¾iny $P$, logické spojky a~zátvorky (, ). Skladanie zlo¾ených výrokov sa riadí týmito pravidlami:
\begin{enumerate}
  \item Ka¾dá prvotná formula $p\in P$ je výroková formula.
  \item Pokiaµ sú $A$, $B$ výrokové formule, potom ($\neg A$),($A\vee B$),($A\wedge B$),($A\rightarrow B$) a~($A\equiv B$) sú výrokové formule.
  \item Ka¾dá výroková formula je poskladaná koneèným poètom symbolov jazyka $L_P$, ktorá vznikne podµa predchádzajúcich pravidiel.
\end{enumerate}

Pravdivostné ohodnotenie prvotných formulí je µubovoµné zobrazenie mno¾iny $P$ na hodnoty {\it true} a~{\it false}. Pre jednoduchos» budeme znaèi» {\it true} 1 a~{\it false} 0. Formálny zápis je $v:P\rightarrow\{0,1\}$. Indukciou podµa zlo¾itosti formule definujeme rozlo¾enie $w$ na zobrazenie $v$ na mno¾inu v¹etkých formulí jazyka $L_P$.
\begin{enumerate}
  \item $w(p)=v(p)$ pre v¹etky $p\in P$
  \item pokiaµ $A$, $B$ sú výrokové formule, potom $w(\neg A)$, $w(A\vee B)$, $w(A\wedge B)$, 
  $w(A\rightarrow B)$ a~$w(A\equiv B)$  v~závistosti od $w(A)$ a~$w(B)$ sa definujú podµa nasledujúcej tabuµky:
\end{enumerate}

\begin{center}
  \begin{tabular}{|c|c||c|c|c|c|c|}
    \hline
    $w(A)$ & $w(B)$ & $w(\neg A)$ & $w(A\vee B)$ & $w(A\wedge B)$ &
    $w(A\rightarrow B)$ & $w(A\equiv B)$ \\
    \hline
    0 & 0 & 1 & 0 & 0 & 1 & 1 \\ 
    0 & 1 & 1 & 1 & 0 & 1 & 0 \\ 
    1 & 0 & 0 & 1 & 0 & 0 & 0 \\ 
    1 & 1 & 0 & 1 & 1 & 1 & 1 \\ \hline
  \end{tabular}
\end{center}

\section{Mo¾nosti reprezentácie funckií}
Logické funkcie sa mô¾u reprezentova» rôznymi spôsobmi. Najèastej¹ie vyjadrenie je v~podobe matematického vzorca za pomoci vy¹¹ie spomínaných operátorov a~funckií. Ma» v¹ak v~poèítaèi funkciu ulo¾enú ako textový re»azec veµmi komplikuje prácu s~òou, preto sa vyvynuli rôzne dal¹ie reprezentácie. Operátory logických funckií sa väè¹inou prevádzajú po rade z~$\vee, \wedge, \neg$ na $+, *, !$.

\paragraph{Pravdivostná tabuµka} Najprehµadnej¹í a~najµah¹ie nauèiteµný typ uchovávania logickej funkcie, bohu¾ial obsahuje veµké mno¾stvo redundancie a~mô¾e ma» veµké pamä»ové nároky ($2^n$, kde $n$ je poèet premenných funkcie).
\paragraph{Logický obvod} Nie moc prehµadný ani µahko nauèiteµný formát, ale vynikajúcí na demo¹tráciu pokroèilých systémov zlo¾ených z~logických funkcií.
\paragraph{BDD} Formát v~podobe acyklického koreòového grafu, ktorému sa budeme ïalej venova» v~kapitole~\ref{TypyBDD}.

\section{Minimalizácia}
Minimalizácia logickej funkcie je proces zni¾ovania pamä»ových nárokov funkcie odstránením redundancie. V~prípade matematického popisu mô¾e ís» o~uplatnenie rôznych redukèných pravidiel. Podrobnéj minimalizácií BDD sa budeme venova» v~kapitole~\ref{TypyBDD}.

\section{Poèet funkcií}\label{logfce}
Stavový priestor logickej funkcie závisí od poètu vstupných premenných a~poètu hodnôt, ktoré ka¾dá premenná mô¾e nadobudnú». Ide o~jednoduchú kombinatoriku, kde zis»ujeme v¹etky variácie vstupných hodnôt, teda $p=n^k$, kde $n$ je poèet hodnôt, ktoré mô¾e nado\-búda» vstupná premenná, $k$ poèet vstupných premenných a~$p$ je výsledny poèet mo¾ných vstupov funkcie.

Výsledný poèet funkcií $r$ je permutácia závisiaca od poètu mo¾ných vstupných kombinácií a~poètu hodnôt, ktoré mô¾e nadobúda» výstup funkcie, teda $r=q^p$, kde $p$ je poèet vstupných kombinácií a~$q$ je poèet hodnôt, ktoré mô¾e výstupná premenná nadobúda». Z~tohto dostávame vzorec
\begin{equation}
  r=q^{n^{k}}.
\end{equation}
Názornej¹ie vyjadrenie poètu logických funckií je pomocou tabuµky pre dve vstupné premenné ($k$=2), dve vstupné hodnoty ($n$=2) a~dve výstupné hodnoty ($q$=2) $= 2^{2^2}=16$ funkcií, viz nasledujúca tabuµka:

\begin{center}
  \begin{tabular}{|c|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multicolumn{2}{|c||}{Vstup}&\multicolumn{16}{c|}{Výstup} \\ \hline
    % x & y  \\ \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
    0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ \hline
    1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ \hline
    1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\ \hline
  \end{tabular}
\end{center} 






\chapter{Binárne rozhodovacie diagramy} \label{kap:bdd}
V~tejto kapitole popí¹eme históriu binárneho rozhodovacieho diagramu BDD, BDD ako matematický formalizmus a~transformovanie BDD na redukované usporiadané BDD: ROBDD.

\section{História}
BDD vznikli z~dôvodu úspornej¹iej reprezentácie logických funckií. Reprezentácia je navrhnutá na základe Shanonovho expazného teorému\cite{Shannon}. Táto dátová ¹truktúra od vzniku v~1959\cite{Lee} pre¹la mnohými úpravami na zní¾enie pamä»ovej nároènosti a~èasovej nároènosti operácií.

Najvýznamnej¹ím milníkom v~oblasti redukcie pamä»ovej nároènosti bola ¹túdia R. E. Bryanta\cite{Bryant} z~Univerzity Carnegie Mellon. Táto ¹túdia sa týka najmä prevádzania operácií nad BDD v~zminimalizovanej forme symbolicky. Toto sa dá poklada» za vznik ROBDD popísaných v~sekcií~\ref{ROBDD}.


\section{Matematický popis}
Táto èas» je prevzatá z~predná¹ky \cite{Vojnar}. BDD je reprezentácia logickej funkcie $\{0,1\}^k\rightarrow\{0,1\},k\geq 0$. Z~pohµadu teorie grafov sa jedná o~koreòový, orientovaný, spojitý acyklický graf. Formálna definícia BDD $G$ nad mno¾inou premenných $M$ je
\begin{equation} \label{bdd:formal} 
  G=(N,T,var,low,high,root,val),
\end{equation}
kde 
\begin{itemize}
  \item $N$ je koneèná mno¾ina neterminálnych uzlov,
  \item $T$ je koneèná mno¾ina terminálnych uzlov (listov), $N\cap T=\emptyset$,
  \item $var \colon N\rightarrow M$ je pomenovanie interných uzlov,
  \item $low, high \colon N\rightarrow N\cup T$ funkcia následníkov, definujúca vysokého a~nízkeho následníka pre daný úzol $n\in N$ pre premennú $var(n)$ so vstupom $0$ alebo $1$,
  \begin{itemize}
    \item graf je acyklický teda $\neg \exists n \in N.n(low\cup high)^+n$,
  \end{itemize}
  \item $root \in N\cup T$ je koreò grafu, teda $\forall n \in (N\cup T)\backslash\{root\}.root(low\cup high)^+n$. Vstupné hrany do uzlú $root$ by poru¹ili acyklicitu grafu,
  \begin{itemize}
    \item $Root(X)$ je funkcia vracajúca $root$ grafu $X$,
  \end{itemize}
  \item $val \colon T\rightarrow \{0,1\}$ je mapovacia funkcia hodnôt terminálnych uzlov.
\end{itemize}


\section{Typy BDD}\label{TypyBDD}
V~tejto kapitole si popí¹eme niektoré základné typy BDD, zdôrazníme rozdiely medzi nimi a~objasníme, v~èom sú niektoré efektívnej¹ie ako iné. Základné princípy budeme demon¹trova» na funkcii

\begin{equation}
  f(x_1,x_2,x_3)=(\neg x_1\wedge \neg x_2 \wedge \neg x_3)\vee(x_1\wedge \neg x_2\wedge \neg x_3)\vee(x_1\wedge x_2\wedge \neg x_3).
\end{equation}

V~texte budeme pou¾íva» nasledujúcu notáciu
\begin{itemize}
  \item Premenné sa znaèia $x_i$, kde $i$ je poradie premennej.
  \item Uzly sa znaèia písmenom $n_{ij}$, kde $i$ je index premennej a~$j$ je poradové èíslo uzlu oznaèovaného premennou.
\end{itemize}
Príklad: $n_{23}$ znaèí tretí uzol premennéj $x_2$.


\subsection{Binárny rozhodovací strom}\label{ROBDD}
Binárny rozhodovací strom (binary decision tree, BDT) sa vytvára ako koreòový graf. Koreò tvorí jedna z~premenných, väè¹inou sa berie prvá premenná funkcie, teda v~na¹om prípade $x_1$. Vytvoríme teda uzol $n_{11}$, ktorý je mapovaný na premennú $x_1$. Premenná mô¾e nadobúda» dvoch hodnôt, pre ktoré sú definované nasledujúce uzly mapované na nasledu\-júcu premennú (uzly $n_{21}$ a~$n_{22}$ mapované na premennú $x_2$). Takto sa postupne zanorujeme, a¾ prejdeme cez v¹etky premenné a~vygenerujeme v¹etky potrebné uzly. Hodnoty priradené za uzly mapované na poslednú premennú sú terminálne uzly. Poèet generovaných uzlov je 
\begin{equation} \label{pocetUzlov}
  \sum_{i=0}^{k} 2^i = 2^{k+1}-1,
\end{equation}
kde $k$ je poèet premenných.

Grafické znázornenie funkcie $f$ je na obrázku~\ref{picBDD}.
\begin{figure}[ht!]
  \includegraphics[bb=0 50 0 230]{fig/bdd1.eps}
  \caption{Základné BDD}
  \label{picBDD}
\end{figure}

\paragraph{Notácia}
Pre orientáciu v~grafe je pou¾itá nasledujúca notácia
\begin{enumerate}
  \item Neterminálne uzly sú
    \begin{itemize}
      \item znaèené krú¾kom,
      \item hierarchicky usporiadané podµa poradia vyhodnocovania
a~\item premenná ovplyvòujúca uzol je písaná vpravo.
    \end{itemize}
  \item Terminály sú
    \begin{itemize}
      \item znaèené ¹tvorèekom,
      \item symbol $\perp$ znaèí hodnotu $\mathit{false}$
a~\item symbol $\top$ znaèí hodnotu $\mathit{true}$.
    \end{itemize}
  \item Hrany sú dvoch typov,
    \begin{itemize}
      \item plná èiara vedie k~vysokému následníkovi daného uzlu $high(n)$
a~\item preru¹ovaná èiara vedie k~nízkemu následníkovi daného uzlu $low(n)$.
    \end{itemize}
\end{enumerate}

Ako vidíme, pre 3 premenné je poèet generovaných uzlov 15, èo odpovedá $2^{3+1}-1$. Zlo¾itos» n8jdenia daného terminálneho uzlu je lineárna vzhµadom k~poètu premenných. Táto reprezentácia obsahuje mnoho redundancie, preto sa nepou¾íva.

\subsection{Redukované BDD}
Poèet generovaných uzlov sa dá výrazne obmedzi» tým, ¾e sa nebudú generova» zbytoèné uzly. Pri pohµade na obrázok~\ref{picBDD} vidíme redundanciu v~terminálnych uzloch. Terminálne uzly mô¾eme zlúèi» do dvoch. Vzniká diagram s~redukovaným poètom terminálnych uzlov, ktorý je znázornený na obrázku~\ref{picRBDD1}.

\begin{figure}[ht!]
  \includegraphics[bb=0 0 0 200]{fig/bdd2.eps}
  \caption{BDD s~redukovaným poètom terminálnych uzlov}
  \label{picRBDD1}
\end{figure}

Ïal¹iou redukciou je zluèovanie izomorfných podgrafov. Keï sa v~BDD nachádzajú dva rôzne uzly, ktoré majú rovnaké (izomorfné) podgrafy, mô¾eme ich zlúèi» do jedného.

\paragraph{Graf} je definovaný ako dvojica $G=(V,H)$, kde $V$ je mno¾ina vrcholov a~$H$ je mno¾ina hrán tvaru $(v_1,v_2)$ kde $v_1,v_2 \in V$, teda $H\subseteq V^2$.
\paragraph{Izomorfizmus} dvoch grafov $G_1=(V_1,H_1)$ a~$G_2=(V_2,H_2)$ je definovaný ako bijektívne zobrazenie $f:V_1\rightarrow V_2$ a~$g:H_1\rightarrow H_2$ také, ¾e µubovoµnej hrane $h\in H_1$ sú priradené vrcholy $x,y\in V_1 \Leftrightarrow$ hrane $g(h)\in H_2$ sú priradené vrcholy $f(x),f(y)\in V_2$.\\Pokiaµ grafy $G_1$ a~$G_2$ sú izomorfné, teda existujú takéto funkcie $f$ a~$g$, potom pí¹eme $G_1 \otimes G_2$.

Strom s~odstránenými izomorfnými podstromami je na obrázku~\ref{picRBDD2}.

\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd3.eps}
  \caption{BDD s~odstránenými izomorfnými podstromami}
  \label{picRBDD2}
\end{figure} 

Ïal¹iou redukciou je vynechávanie uzlov, kde $low(n) = high(n)$,pre $n\in N$. Ak sa vysoký aj nízky následník odkazujú na izomorfné podgrafy, logická funkcia v~tomto bode nezávisí od danej premennej, preto sa mô¾e tento uzol vynecha». Výsledný strom je na obrázku~\ref{picRBDD3}.

\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 230]{fig/bdd4.eps}
  \caption{Výsledné minimalizované BDD}
  \label{picRBDD3}
\end{figure}

\newpage
\paragraph{RBDD} je klasické BDD, pre ktoré platia nasledujúce pravidlá:
\begin{enumerate}
  \item $\neg\exists n\in N.low(n)=high(n)$
  \item $\neg\exists x_1,x_2\in N \cup T.x_1\neq x_2\wedge Root(G_1)=x_1\wedge root(G_2)=x_2 \wedge G_1 \otimes G_2$
\end{enumerate}


\subsection{Redukované usporiadané BDD} 
Poradia vyhodnocovania premenných, ktoré ovplyvòujú uzly, majú veµký vplyv na poèet generovaných uzlov. Pre ilustráciu si to predveïme na funkcii
\begin{equation}
  y(x_1,...,x_8) = (x_1 \wedge x_2)\vee(x_3 \wedge x_4)\vee(x_5 \wedge x_6)\vee(x_7 \wedge x_8).
\end{equation}
RBDD odpovedajúce danej funkcii pre dve rôzne usporiadania je na obrázku~\ref{picROBDD}.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=150mm]{fig/bdd5.jpg}
  \caption{Rozdiel medzi zlým a~dobrým usporiadaním\cite{WikiOrder}}
  \label{picROBDD}
\end{figure}
\par
Obe BDD sú minimalizované a~popisujú rovnakú logickú funckiu. Z~pravého obrázku v¹ak vidíme, ¾e dobrým usporiadaním výrazne zní¾ime poèet generovaných uzlov. Na zistenia optimálneho usporiadania v¹ak neexistuje doposiaµ ¾iadný efektívny algoritmus preto¾e sa jedná o~NP-nároèný problém. Existujú iba rôzne heuristiky. Tie nám v¹ak mô¾u pomôc», teda dostaneme výsledný strom s~men¹ím poètom uzlom, ale aj u¹kodi». Tu je zoznam niektorých pou¾ívaných algoritmov:

%BDD-dip
\textbf{Náhodný algoritmus}\cite{Rucky} Algoritmus sa pou¾íva v~dvoch variantách a~to varianta s~pivotom a~varianta bez pivota. Varianta bez pivota vyberá dve náhodné premenné v~grafe a~tie vymení postupným vymieòaním susedných uzlov. Výsledné usporiadanie premenných pre danú iteráciu je ulo¾enie s~najmen¹ím poètom uzlov v~priebehu itérácie. Varianta s~pivotom pracuje na rovnakom princípe, ale pred samotným algoritmom sa vyberie pivot. To je premenná s~najvy¹¹ím poètom uzlov. Dve náhodne zvolené premenné sú také, ¾e jedna sa nachádza nad a~druhá pod pivotom. 

\textbf{Sifting algoritmus} \cite{Rudell} Teória je spoèíta» najvýhodnej¹iu pozíciu v~grafe pre jednu premennú s~tým, ¾e ostatné premenné zachovajú svoje poradie. Premennú posúvame najskôr smerom k~terminálnym uzlom, potom smerom ku koreòu. Po príchode do koreòu vieme, v~ktorej pozícií mala premenná najmenej uzlov a~posunieme ju tam. Posun sa vykonáva na základe prehadzovania susedných premenných.

Iné pou¾ívané algoritmy sú napríklad
\begin{itemize}
  \item{Symmetric sifting algoritmus}
  \item{Group sifting algoritmus}
  \item{Window permutation algoritmus}
  \item{Algoritmus vyu¾ívajúci genetické algoritmy}
\end{itemize}

Samotné spú¹»anie preusporiadania premenných mô¾e by» rôzne, napríklad dosiahnutie urèitého poètu výpoèetných krokov, alebo doposiaµ generovaný poèet uzlov.

\section{Procedúra \emph{Apply()}} \label{apply}
Procedúra \emph{Apply()} aplikuje booleovskú funkciu na BDD. Obecne mô¾e by» $k$-árna. V~takom prípade dostáva procedúra $k$ diagramov a~funkciu, ktorú má nad diagramami vykona». Výsledkom procedúry je jedno BDD. 

Základný princíp funkcie je odvodený z~Shannonovho expandného teorému, ktorý je popísaný v~literatúre\cite{Shannon}. Ide o~restrikciu urèitej premennej v~grafe za konkrétnu hodnotu. Nech je $n$-parametrová funkcia $f(v_1,\dots,v_n)$. Vykonanie restrikcie nad funkciou $f$, premennej $v_i$ za hodnotu $a$ dostávame funkciu $f(v_1,\dots,v_{i-1},a,v_{i+1},\dots,v_n)$, skrátene písané $f|_{v_i\leftarrow a}(v_1,\dots,v_n)$. Pokiaµ prevedieme restrikciu na v¹etky premenné, výsledok konrétneho dotazu nad funkciou u¾ nie je rozhodovacia funkcia, ale konkrétna hodnota. Podµa Shannonovho torému platí 
$$f(v_1,\dots v_n)=(\neg v_1\wedge f|_{v_i\leftarrow 0}(v_1,\dots,v_n))\vee(v_1\wedge f|_{v_i\leftarrow 1}(v_1,\dots,v_n)).$$
Buï $f_1,\dots,f_k$ $k$ funkcií nad rovnakou doménou premenných a~$op()$ $k$-árny operátor nad BDD. Operátor $op()$ vykonáva restrikciu nad v¹etkými funkciami nasledovne: 
$$op(f_1,\dots,f_k)=(\neg v\wedge op(f_1|_{v\leftarrow 0},\dots,f_k|_{v\leftarrow 0}))\vee(v\wedge op(f_1|_{v\leftarrow 1},\dots,f_k|_{v\leftarrow 1})).$$

Restrickia sa pri tvorbe BDD pomocou funkcie $f$ vyu¾íva pre ka¾dý uzol $n$ nasledovne:
\begin{itemize}
  \item $low(n)=\neg var(n) \wedge f|_{n\leftarrow 0}$
  \item $high(n)=var(n) \wedge f|_{n\leftarrow 1}$
  \item $f(n)=high(n)\vee low(n)$
\end{itemize}

Postupným zanorovaním restrikcie vzniká rekurzívny algoritmus popísaný v~algoritme~\ref{algApply} pre binárne \emph{apply}. Operátor $a\prec b$ znaèí, ¾e premenná $a$ sa nachádza bli¾¹ie ku koreòu ako premenná $b$.
\begin{algorithm}[h]
  \caption{Apply} \label{algApply}
  \SetAlgoLongEnd
  \LinesNumbered
  \SetNlSty{normal}{}{:}
 
  \KwIn{$X,Y\in N\cup T,\mathit{func}\colon \{0,1\}^n\rightarrow\{0,1\}$}
  \KwOut{$\mathit{result}$ je výsledok funkcie $\mathit{func}(X,Y)$}
\medskip
  $xh = X$, $xl = X$, $yh = Y$, $yl = Y$\;
  \eIf{($X,Y\in T$)}{
    \Return $\mathit{func}(X,Y)$ \;
  }{
    \eIf{($X\prec Y$)}{
      $\mathit{result}:=\mathit{var(X)}$\;
      $xh=high.X$, $xl=low.X$\;
    }{
      \eIf{($Y\prec X$)}{
        $\mathit{result}:=\mathit{var(Y)}$\;
        $yh=high.Y$, $yl=low.Y.$\;
      }{
        $\mathit{result}:=\mathit{var(X)}$\;
        $xh=high.X$, $xl=low.X$, $yh=high.Y$, $yl=low.Y$\;
      }
    }
  }
  $\mathit{result.high=Apply(xh,yh,\mathit{func})}$\;
  $\mathit{result.low=Apply(xl,yl,\mathit{func})}$\;
  \medskip
  \eIf{$(\mathit{low.result=high.result})$}{
    $\mathit{result=low.result}$\;
  }{
    \If{$(\mathit{tmp}:=\mathit{cache[result]})$}{
      uvolni $\mathit{result}$\;
      $\mathit{result}:=\mathit{tmp}$\;
    }
  }
  \medskip
  \Return $\mathit{result}$\;
\end{algorithm}



\section{Multiterminálne BDD}
Formálna definácia MTBDD je rovnaká ako definiícia~\ref{bdd:formal} pre BDD s~rozdielom, ¾e v~MTBDD mno¾inu $\mathit{val}$ definujeme takto:
\begin{itemize}
  \item $\mathit{val} \colon T \rightarrow \mathds{D}$, kde $\mathds{D}$ je potenciálne nekoneèná mno¾ina.
\end{itemize}

Multiterminálne BDD sú vo svojej podstate obyèajné ROBDD, ktoré majú väè¹í, obecne neobmedzený poèet terminálnych uzlov. Ako príklad si mô¾eme uvies» kombinaèný systém\footnote{Stav závisí iba na kombinácii vstupu}, ktorý sa mô¾e nachádza» v~stavoch $S_{\mathit{off}}$, $S_{set}$ a~$S_{count}$. Vstupné premenné sú $X_{on}$ a~$X_{count}$. Tabuµka systému je 
\begin{center}
  \begin{tabular}{|c|c||c|}
    \hline
    $X_{on}$ & $X_{count}$ & $S(X_{on}, X_{count})$ \\ \hline
    0 & 0 & $S_{\mathit{off}}$ \\ \hline
    0 & 1 & $S_{\mathit{off}}$ \\ \hline
    1 & 0 & $S_{set}$ \\ \hline
    1 & 1 & $S_{count}$ \\ \hline
  \end{tabular}
\end{center}

Na miminalizáciu MTBDD sa dajú pou¾i» opä» pou¾i» obe techniky, teda odstránenie izomorfných podstromov a~uzlov, kde $\mathit{high}(x)=\mathit{low}(x)$. Podµa tabuµky jednoducho zostrojíme a~zminimalizujeme BDD, ktoré v¹ak nemá iba 2 terminálne hodnoty ale 3. 

\begin{figure}[ht!]
  \includegraphics[bb=-100 0 0 250]{fig/bdd6.eps}
  \caption{Príklad MTBDD}
  \label{picMTBDD}
\end{figure}



  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Porovnání dostupných programových balíkù pro manipulaci
% s binárními rozhodovacími diagramy, Martin Felcman, BP, 2008
% felcmm1_2008bach.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dostupné balíky} \label{kap:baliky} 
V~tejto kapitole si popí¹eme niektoré kni¾nice pracujúce s~BDD. Bude popísaná ¹truktúra uzlu a~spôsob práce s~diagramami.

\section{CUDD}
Balíèek bol vyvíjaný na univerzite v~Coloradu. U¾ od roku 1996 stálym vývojom dosiahol vynikajúce pamä»ové a~výkonnostné výsledky. Podporuje prácu s~BDD, diagramami s~potlaèenou nulou (ZDD) a~aritmetickými rozhodovacími diagramami (ADD). ADD sú MTBDD, kde doménu $\mathds{D}$ tvoria èísla s~plávajúcou rádovou èiarkou. V~kni¾nici je taktie¾ implementovaná sada algoritmov na zlep¹enie usporiadania premenných. Balíèek sa mô¾e pou¾íva» 3 spôsobmi:
\begin{enumerate}
  \item {Black box}\,--\,Umo¾òuje pou¾íva» iba exportované funkcie popísané v~nápovede.
  \item {Clean box}\,--\,Umo¾nuje písanie zlo¾itej¹ích projektov, kde je vzhµadom k~efektivite nutné prida» do balíka vlastné funkcie.
  \item {Interface}\,--\,Balík disponuje kvalitne spracovaním rozhraním pre prácu s~BDD ako objektami.
\end{enumerate}
Podrobná definícia celého balíka CUDD je popísaná v~literatúre\cite{cudd}.

\subsection{©truktúra uzlu}
\begin{lstlisting}
struct DdNode{
  DdHalfWord index;
  DdHalfWord ref;
  DdNode *next;
  union{
    CUDD_VALUE_TYPE value;
    DdChildren kids;
  } type;
};
\end{lstlisting}
©truktúra reprezentuje terminálne aj neterminálne uzly. Na zistenie, èi konkrétny uzol je terminálny slú¾i makro \texttt{Cudd\_IsConstant()}. Makro sa pozerá na index uzlu. Najvy¹¹í index je rezervovaný pre terminálne uzly. V~premennej \texttt{index} je ulo¾ený názov premennej, podµa ktorej je pomenovaný uzol. Odrá¾a poradie vzniku uzlov. V~premennej \texttt{ref} je poèítadlo referencií na uzol. Premenná \texttt{next} ukazuje na daµ¹í uzol v~unique table. Ak ide o~terminálny uzol, obsahuje premennú \texttt{value}, ktorá znaèí hodnotu uzlu, ináè obsahuje ¹truktúru \texttt{kids}, kde sú ulo¾ené ukazatele na vysokého a~nízkeho následníka daného uzlu. 
\\
\subsection{Manager}
V¹etky pou¾ité uzly sú ulo¾ené v~¹pecialnej hashovaciej tabuµke (unique table). BDD a~ADD zdieµajú rovnakú tabuµku, ZDD má svoju vlastnú. Manager sa pred pou¾itím inicializuje funkciou \texttt{Cudd\_Init()} a~po pou¾ití ru¹í funckiou \texttt{Cudd\_Quit()}.

\subsection{Zhrnutie}
CUDD je univerzálny balíèek pre prácu s~BDD. Má kvalitne spracovanú dokumentáciu vèetne u¾ivateµského a~programátorského manuálu. Výhodou je disponovanie ¹irokou ¹kálou funkcií pre radenie poradia premenných. 



\section{BuDDy}
Táto kni¾nica bola vytvorená ako súèas» dizertaènej práce. Spoèiatku bola urèená len na demo¹tráciu princípov BDD. Vo svojej poslednej verzií je u¾ v¹ak plnohodnotným balíkom so v¹etkými ¹tandartnými operáciami, radením poradia premenných a~dokumentáciou.

\subsection{©truktúra uzlu}
\begin{lstlisting}
typedef struct s_BddNode{
  unsigned int refcou : 10;
  unsigned int level : 22;
  int low;
  int high;
  int hash;
  int next;
} BddNode;
\end{lstlisting}

Je potrebné uvies», ¾e BuDDy nepracuje s~managerom ale s~poµom uzlov, preto v¹etky premenné, ktoré odkazujú nejaký uzol sú reprezentované ako index do tohto poµa.

Premenná \texttt{refcou} obsahuje poèet referencií vedúcich na uzol. Premenná \texttt{level} ukazuje pozíciu premennéj pri súèastnom ulo¾ení. Premenné \texttt{high} a~\texttt{low} reprezentujú hrany, \texttt{next} je ukazateµ na nasledujúci uzol. Premenná \texttt{hash} je ukazateµ na koreò stromu.
\\
\subsection{Zhrnutie}
BuDDy je kompletný balík na prácu s~BDD. Podporuje usporiadavanie premenných. BuDDy má veµmi kvalitne spracované C\verb!++! rozhranie, ktoré zefektívòuje prácu s~týmto balíkom.


\section{CacBDD}
Jedná sa o~kni¾nicu vyvýjanú v~jazyku C\verb!++!, ktorá je podobne ako BuDDy zalo¾ená na indexovaní v~poli. Podporuje obvyklé operátory vyu¾ívané v~modelcheckingu. CacBDD má kvalitne spracované ukµadanie medzivýsledkov, vïaka èomu dosahuje výborné èasové výsledky.

Kni¾nica je veµmi jednoducho popísaná v~literatúre\cite{cacbdd}. Ja som potrebné informácie nachádzal priamo v~zdrojových súboroch dostupných z~\url{http://www.kailesu.net/CacBDD/CacBDD.zip}.

\subsection{©truktúra uzlu}
\begin{lstlisting}
class DdNode{
  public:
    int var;     
    int Then;
    int Else;
    int Next;
    
    // metody
}
\end{lstlisting}

Jeden uzol je ulo¾ený v~triede \texttt{DdNode}. Táto ¹truktúra je ulo¾ená v~poli, preto sú odkazy typu \texttt{int} a~reprezentujú index do tohto poµa. \texttt{var} znaèí index premennej, \texttt{Then} a~\texttt{Else} sú indexy následníkov a~\texttt{Next} obsahuje index následujúcej voµnej premennej.

Súèas»ou triedy sú aj metody na vytvorenie objektu, jeho zru¹enie a~nastavenie hodnôt.
\\
\subsection{Medzivýsledky}
V~CacBDD slú¾i na ukladanie medzivýsledkov ¹truktúra \texttt{XCTable}, ktorá sa dynamicky mení v~závislosti od tzv. \texttt{hit-rate}, èo¾ je pomer zásahov do tabuµky k~celkovému poètu dotazov nad tabuµkou. \texttt{hit-rate} sa dynamicky so zmenami v~tabuµke mení, èím dochádza k~zmene veµkosti tabuµky.

\subsection{Zhrnutie}
Balík CacBDD je ïal¹í kvalitne spracovaný balík pre prácu s~BDD. Vyu¾íva indexový prístup k~uzlom. Návrhári balíku sa zamerali hlavne na jeho rýchlos», ktorá je dos» vysoká vzhµadom k~implementácií dynamického ukladania medzivýsledkov. V~literatúre\cite{cacbdd} je mo¾né nájs» aj rýchlostné zrovnanie s~balíkom CUDD. 










\chapter{Návrh a~implementácia}
V~tejto kapitole popí¹em svôj návrh implementácie jednotlivých dátových ¹truktúr a~algoritmov. Kni¾nica je implementovaná v~jazyku C a~prekladaná pomocou prekladaèa \texttt{gcc} s~prepínaèmi \texttt{-std=c99}, \texttt{-Wall}, \texttt{-Wextra}  a~\texttt{-pedantic}.

\section{Dátové ¹truktúry}
V~tejto èasti sa zoznámime s~návrhom jednotlivých dátových ¹truktúr, ako sú navzájom previazané a~ktorá polo¾ka ¹truktúry na èo slú¾i.

\subsection{BDD uzol}\label{tBddNode}
Základnou jednotkou ka¾dého grafu je uzol. Môj návrh uzlu obsahuje v¹etky dôle¾ité premenné pre úplnu prácu s~ním.
\begin{lstlisting}
typedef struct BddNode{
  struct BddNode *high, *low;
  unsigned int var;
  unsigned int ref;
  struct BddNode *nextFree;
}tBddNode;
\end{lstlisting}
Premenné \texttt{high} a~\texttt{low} sú ukazatele na vysokého a~nízkeho následníka uzlu. V~prípade, ¾e ide o~terminálny uzol, \texttt{high} a~\texttt{low} sú nastavené na \texttt{NULL}. Na zistenie, èi je daný uzol \texttt{t} terminálny sa pou¾íva makro \texttt{isTerminal(t)}. Premenná \texttt{var} je index do tabuµky mien premenných, ktorú si detailnej¹ie popí¹eme v~sekcií~\ref{tLabels}. Premenné \texttt{ref} a~\texttt{nextFree} sú premenné, ktoré vyu¾íva garbage collector. \texttt{ref} je poèítadlo referencií, ktoré je dôle¾ité pri zdielaných uzloch a~\texttt{nextFree} je ukazateµ, ktorý previazáva zoznam voµných premenných ktoré má k~dispozícií manager. Manageru sa budeme viac venova» v~èasti~\ref{tManager}.

\subsection{Garbage collector}\label{tGarbage}
Garbage collector má jednoduchú ¹truktúru.
\begin{lstlisting}
typedef struct Garbage{
  tBddNode *nodes;
  struct Garbage *next;
}tGarbage;
\end{lstlisting}
Premenná \texttt{nodes} ukazuje na pole v¹etkých uzlov a~premenná \texttt{next} na pola ïal¹ieho kusu pamäti, ktorý sa alokuje v~prípade, ¾e manager nemá voµné uzly.

\subsection{Mená premenných} \label{tLabels}
Je indexované pole re»azcov. ©truktúra je taktie¾ veµmi jednoduchá.
\begin{lstlisting}
typedef struct Labels{
  char **lab;
  unsigned int count;
}tLabels;
\end{lstlisting}
Premenná \texttt{lab} je odkaz na pole re»azcov\footnote{Re»azcom je myslený typ \texttt{char *}.} a~\texttt{count} je premenná oznaèujúca poèet re»azcov, pou¾ívana hlavne pri realokácií prvej úrovne \texttt{lab}.

\subsection{Medzivýsledky\,--\,\emph{Cache}} \label{tCache}
Medzivýsledky zni¾ujú pamä»ové nároky na tvorbu BDD a~zjednodu¹ujú zdielanie podgrafov. ©truktúra je nasledujúca. Implementácia medzivýsledkov je ako hashovacia tabuµka, ktorej klúè pre daný uzol sa spoèíta z~trojice $[high,low,var]$ daného uzlu. Dátová ¹truktúra nesúca informáciu tj. trojicu $[high,low,var]$ a~ukazateµ na uzol obsahujúci túto trojicu je nasledovná.
\begin{lstlisting}
typedef struct CacheItem{
  unsigned int var;
  tBddNode *high, *low, *address;
  struct CacheItem * next;
} tCacheItem;
\end{lstlisting}
Premenné \texttt{high},\texttt{low},\texttt{var} a~\texttt{address} nesú informáciu o~uzle. Premenná \texttt{next} preväzuje uzly. V~prípade ¾e je uzol voµný tvorí zoznam so v¹etkými voµnými uzlami, v~prípade ¾e je uzol pou¾ívaný, tvorí zoznam v~hashovacej tabuµke. Táto ¹truktúra, podobne ako ¹truktúra \texttt{tNodes} sa alokuje ako pole, ktoré je ulo¾ené v~bloku \texttt{tCacheGar}. ©truktúra je nasledujúca.
\begin{lstlisting}
typedef struct CacheGar{
  tCacheItem * nodes;
  struct CacheGar * next;
} tCacheGar;
\end{lstlisting}
Premenná \texttt{nodes} ukazuje na pole odkiaµ sa priradzujú cache záznamy. \texttt{next} zabezpeèuje previazanie týchto ¹truktúr do zoznamu. Ïal¹í blok ¹truktúry sa alokuje v~prípade, ¾e poèet voµných cache záznamov je 0. Toto zistíme zo zastre¹ujúcej ¹truktúry \texttt{tCache}.
\begin{lstlisting}
typedef struct Cache {
  tCacheGar * gar;
  tCacheItem * free;
  tCacheItem ** hash;
} tCache;
\end{lstlisting}
Nosná ¹truktúra, ktorá má nastaros» celý managment medzivýsledkov. \texttt{gar} je zoznam v¹etkých záznamov, ktoré mô¾eme pou¾i». \texttt{free} sú previazané zatiaµ nepou¾ité uzly. \texttt{hash} je odkaz do hashovacej tabuµky, do ktorej sa ukadajú záznamy medzivýsledkov.


\subsection{BDD manager}\label{tManager}
Zastre¹ujúca ¹truktúra, riadiaca celú tvorbu a~úpravy BDD.
\begin{lstlisting}
typedef struct Manager{
  tGarbage *nodes;
  tBddNode *free;
  tLabels *variables;
  tLabels *terminals;
  tCache *cache;
}tManager;
\end{lstlisting}
\texttt{nodes} je ukazateµ na ¹truktúru garbage collectoru, ktorá ma nastarosti uvoµnovanie a~vytváranie nových zhlukov uzlov. \texttt{free} je ukazateµ na prvý voµný uzol. Ide opä» o~zoznamovú implementáciu, kde sú v¹etky uzly prepojené pomocou \texttt{nextFree}, popísaného v~èas»i~\ref{tBddNode}. \texttt{cache} je ¹truktúra starajúca sa o~vytváranie medzivýsledkov. \texttt{variables} a~\texttt{terminals} sú tabuµky mien uzlov. 

\subsection{Výèet chybových stavov}
Pri vykonávaní programu mô¾e pri niektoréj operácií dôjs» k~výskytu chyby ako je napríklad nedostatok pamäti. Tieto chybové stavy sú zapúzdrené vo výètovom type \texttt{tError}. Balík disponuje makrom 
\begin{verbatim}bddThrowError(
    tError     e, 
    tManager * mgr),
\end{verbatim}
ktoré v~prípade vzniknutej chyby ukonèuje program s~odpovedajúcou správou pre u¾ivateµa. Makro vytlaèí odpovedajúcu chybovú hla¹ku k~chybe predanej parametrom \texttt{e}, uvoµní prostriedky managera predaného parametrom \texttt{mgr} a~ukonèuje program chybovým kódom \texttt{e}. Kni¾nica nepou¾íva makro sama, ale chybu propaguje vy¹¹ie. O¹etrenie týchto chýb má rie¹i u¾ivateµ.

\section{Algoritmy}
Hlavné u¾ivateµské rozhranie tvoria funkcie \texttt{bddInit()}, ktorá inicializuje v¹etky komponenty pre manager, \texttt{bddDestroy()}, ktorá uvoµnuje v¹etky prostriedky, ktoré daný manager alokoval, \texttt{bddCreateNode()} a~\texttt{bddCreateTerminal()}, ktoré vytvoria uzol pre danú premennú alebo terminál a~funkcia \texttt{bddApply()}. 

\subsection{Inicializácia}
®iadnu z~operácií nie je mo¾né prevádza» nad neinicializovaným managerom. Na inicializáciu slú¾i funkcia 
\begin{verbatim}bddInit(
    tManager      * mgr, 
    unsigned int    size),
\end{verbatim}
ktorá postupne inicializuje v¹etky prvky premennej \texttt{mgr}. Najdôle¾itej¹iu èas»ou je inicializácia premennej \texttt{nodes}, ktorá vytvorí pole uzlov podµa zadanej veµkosti. V¹etky tieto uzly sú prístupné zo zoznamu v~premennej \texttt{free}. Automaticky sa generujú dva uzly \texttt{bddFalse} a~\texttt{bddTrue} prístupné na globálnej úrovni. Funckia zapúzdruje inicializáciu v¹etkých vlastných premenných.

Parameter \texttt{size} je veµkos» na akú sa manager inicializuje. V~balíku sú 3 preddefinované kon¹tanty a~to \texttt{BDD\_SMALL}, \texttt{BDD\_MEDIUM} a~\texttt{BDD\_LARGE}.

\subsection{Uvolòovanie}
Na uvolnenie slú¾i funkcia \texttt{bddDestroy(tManager *mgr)}, ktorá postupne zru¹í v¹etky alokované ¹truktúry. Je neprípustné ukonèi» program pred zavolaním tejto funkcie, preto ¾e by dochádzalo k~únikom pamäti.

Postupne sa uvolòujú prostriedky garbage collectora, tj. zru¹ia sa uzly a~potom sa dealokuje ¹truktúra. Je potreba dáva» pozor na to, ¾e garbage collector je zoznam, teda je potrebné ho uvolni» korektne celý a~nie iba prvý blok pamäti. Cache tvorí taktie¾ zoznam, preto sa musí uvolòova» postupne. Uvolnenie ¹truktúry návestí je iba volanie funkcie \texttt{free()} nad premennou ¹truktúry \texttt{lab}. Ïalej sa u¾ uvolòuje iba samotná ¹truktúra. 

Premenná \texttt{free} je iba pomocný ukazateµ, teda sa neuvoµnuje. Miesto ktoré odkazoval bolo uvoµnené pri uvoµnovaní premennej \texttt{nodes}.

\subsection{Vytvorenie uzlu}
Na vytváranie uzlov sa pou¾íva funkcia 
\begin{verbatim}bddCreateNode(
    tManager *  mgr, 
    char     *  label, 
    tBddNode *  high, 
    tBddNode *  low, 
    tBddNode ** res).
\end{verbatim}
Parametry funkcie sú \texttt{mgr} èo¾ je manager nad ktorým pracujeme, \texttt{label} je meno vytváraného uzlu, ktoré sa ukladá do premennej manageru \texttt{variables}, \texttt{high} a~\texttt{low} sú ukazatele na potomkov a~\texttt{res} je výstupný parameter, cez ktorý vraciame ukazateµ na uzol. Návratová hodnota funkcie je chybový kód v~prípade, ¾e nám do¹la pamä». Funkcia nastavuje uzlu v¹etky jeho informácie a~to takto:
\begin{enumerate}
  \item Nastavíme premennú \texttt{var} na index v~tabuµke \texttt{variables}.
  \item Prehµadáme medzivýsledky, èi takýto uzol u¾ neexistuje.
  \begin{itemize}
    \item Ak existuje, vraciame ukazateµ z~medzivýsledkov.
    \item Ak neexistuje, pokraèujeme.
  \end{itemize}
  \item Poèítadlo referencií \texttt{ref} nastavíme na 1.
  \item Oznaèíme uzol ako pou¾ívaný nastavením \texttt{nextFree} na \texttt{NULL}.
  \item Vysokému následníkovi uzlu \texttt{high} priradíme hodnotu parametru \texttt{high}.
  \item Nízkemu následníkovi uzlu \texttt{low} priradíme hodnotu parametru \texttt{low}.
\end{enumerate}
V~prípade nového terminálneho uzla sa pou¾íva funkcia 
\begin{verbatim}bddCreateTerminal(
    tManager *  mgr,
    char     *  label,
    tBddNode ** res). 
\end{verbatim}
Parametre reprezentujú to isté ako vo funkcií \texttt{bddCreateNode()}. Sú tu iba nepatrné zmeny v~implementácií:
\begin{itemize}
  \item Návestie sa vkladá do tabuµky \texttt{terminals}.
  \item Referencie sa na terminálnych uzloch nepoèítajú.
  \item Do \texttt{high} a~\texttt{low} priradíme \texttt{NULL}.
\end{itemize}

\subsection{Práca s~mezdivýsledkami\,--\,\emph{Cacheovanie}} 
Ka¾dý vytvorený uzol (s~výnimkou terminálnych) sa ukladá do ¹truktúry popísanej v~èasti~\ref{tCache}. Ukladajú sa ako trojica vysokého následníka, nízkeho následníka a~návestia premennej. Ïalej sa ukladá adresa tohto uzlu. Pri vytváraní uzlu najskôr skontrolujeme medzivýsledky pomocou funckie 
\begin{verbatim}cacheCheck(
    tCache        * c, 
    tBddNode      * high, 
    tBddNode      * low, 
    unsigned int    var).
\end{verbatim}    
Ak daný uzol u¾ existuje, funkcia vracia ukazateµ na uzol. V~prípade ¾e uzol e¹te neexistuje, vracia sa \texttt{NULL}. V~tomto prípade sa uzol vkladá do cache pomocou funkcie \texttt{cacheInsert()}.

\subsection{Práca s~referenciami}
Pre prácu s~referenciami sa pou¾ívajú dve funkcie a~to 
\begin{verbatim}nodeIncRef(
    tBddNode * node)
\end{verbatim} a 

\begin{verbatim}nodeDecRef(
    tManager * mgr, 
    tBddNode * node).
\end{verbatim}

Funkcia \texttt{nodeIncRef()} zvy¹uje poèítadlo referencií na uzol. Volá sa implicitne pri vytváraní uzlu za predpokladu, ¾e uzol u¾ existuje a~bol najdený v~medzivýsledkoch.

Funkcia \texttt{nodeDecRef()} naopak zni¾uje poèítadlo referencií. Programátor ju musí vola» explicitne nad ka¾dým ukazateµom na graf, ktorý u¾ nemieni pou¾íva». V~prípade, ¾e poèítadlo referencií daného uzlu klesne na 0, uzol je automaticky uvoµnený z~pou¾ívaných uzlov aj z~medzivýsledkov. Funkcia sa rekurzívne volá aj na potomkov. Takýmto spôsobom sa dajú ru¹i» celé zhluky uzlov.

\subsection{Procedúra \emph{Apply()}} 
Základný princíp procedúry bol u¾ popísaný v~èasti~\ref{apply}. Implementáciu v~kni¾nici tvoria dve funkcie. Prvá je 
\begin{verbatim}bddApply(
    tManager  * mgr,
    tBddNode  * x, 
    tBddNode  * y, 
    tBddNode  * (*func) (tBddNode *, tBddNode *)), 
\end{verbatim}
ktorá sa volá z~u¾ivateµského programu. Ako parameter dostáva dva ukazatele na grafy (\texttt{x} a~\texttt{y}), manager, v~ktorom sa má procedúra vykona» (\texttt{mgr}) a~odkaz na funkciu, ktorá sa má vykona» na terminálnych uzloch (\texttt{func}). Funkcia spú¹»a rekurzívnu funkciu \texttt{\_apply()} s~rovnakými parametrami. \texttt{\_apply()} sa rekurzívne zanoruje podµa algoritmu~\ref{algApply} popísaného v~èasti~\ref{apply}. 

Pri vytváraní nových uzlov v~procedúre sa pou¾íva funkcia 
\begin{verbatim}bddNewNode(
    tManager     *  mgr, 
    unsigned int    var, 
    tBddNode     *  high, 
    tBddNode     *  low, 
    tBddNode     ** res), 
\end{verbatim}
ktorá vytvára nový uzol s~tým rozdielom, ¾e nekontroluje medzivýsledky. Funkcia \texttt{\_apply} kontroluje medzivýsledky a¾ pri rekurzívnom vynorovaní, keï sa pridajú danému uzlu korektní potomkovia. Taktie¾ sa pri vynorovaní kontroluje, èi potomkovia nie sú rovnakí. V~takom prípade sa uzol ru¹í a~vracia sa ukazateµ na potomka.

Kni¾nica disponuje základnými logickými funkciami, ktoré mô¾u by» ako parameter funkcie \texttt{bddApply()}. Tieto funkcie sú \texttt{bddOr()}, \texttt{bddNor()}, \texttt{bddAnd()}, \texttt{bddNand()}, \texttt{bddXor()}, \texttt{bddImp()} a~\texttt{bddNeg()}.  V~prípade pou¾itia \texttt{bddNeg()}, funkcia \texttt{bddApply()} predáva ako parameter funkcie \texttt{\_apply()} dva rovnaké ukazateµe na grafy a~funkciu \texttt{bddNand()}.

\subsection{Práca s~MTBDD}
Ako bolo u¾ vy¹¹ie spomínané, balík pracuje na globálnej úrovni kvôli premenným \texttt{bddTrue} a~\texttt{bddFalse}. Z~tohto dôvodu pri práci s~MTBDD musí u¾ivateµ vytvára» uzly na globálnej úrovni. To znaène obmedzuje prácu s~nekoneènými mno¾inami. Inak sa s~MTBDD pracuje rovnakým spôsobom ako s~BDD. 

\subsection{Uká¾ky kódov}
Predvedieme si niektoré kon¹trukcie, ktoré sa vyu¾ívajú na tvorbu rozhodovacích diagramov.

\subsubsection{Jednoduchá binárna funkcia}
Nasledujúci kód vytvorí funkciu 
$$f(a,b,c) = (a\wedge \neg b) \vee (\neg c\wedge d)$$

\begin{lstlisting}
#include "bdd.h"

int main() {
  tError e;
  tManager manager;
  tBddNode *a, *b, *c, *d, *tmp;
  
  e = bddInit(&manager,BDD_SMALL);
  if(e) bddThrowError(e,&manager);

  e = bddCreateNode(&manager,"a",bddTrue,bddFalse,&a);
  if(e) bddThrowError(e,&manager);
  e = bddCreateNode(&manager,"b",bddFalse,bddTrue,&b);
  if(e) bddThrowError(e,&manager);
  e = bddCreateNode(&manager,"c",bddTrue,bddFalse,&tmp);
  if(e) bddThrowError(e,&manager);
  c = bddApply(&manager,tmp,NULL,bddNeg);
  nodeDecRef(&manager,tmp);
  
  e = bddCreateNode(&manager,"d",bddTrue,bddFalse,&d);
  if(e) bddThrowError(e,&manager);
  
  tmp = bddApply(&manager,a,b,bddAnd);
  nodeDecRef(&manager,a);
  nodeDecRef(&manager,b);
  
  a~= bddApply(&manager,c,d,bddAnd);
  nodeDecRef(&manager,c);
  nodeDecRef(&manager,d);
  
  b = bddApply(&manager,a,tmp,bddOr);
  nodeDecRef(&manager,a);
  nodeDecRef(&manager,tmp);

  printTree(&manager,b);

  bddDestroy(&manager);
  return 0;
}
\end{lstlisting}
Teraz si tro¹ku detailnej¹ie rozoberieme kód. Na zaèiatku inicializujeme manager. Postupne vytvárame uzly pre premenné $a$,$b$,$c$ a~$d$. Sú tu ukázané dva rôzne druhy vytvorenia uzlu popisujúceho negáciu. Prvý je pri inicializácií premennej \texttt{b} pomocou vymenených parametrov \texttt{high} a~\texttt{low}. Druhý je pomocou funkcie \texttt{bddApply()} a~funkcie negácie.

Po ka¾dom volaní funkcie \texttt{bddApply()} je volaná funkcia \texttt{nodeDecRef()} nad grafmi predanými ako parameter \texttt{bddApply()}. Je to z~dôvodu, ¾e \texttt{bddApply()} nijako nemodifikuje pôvodné grafy a~vytvára úplne nové. Pokiaµ nechceme u¾ s~ukazateµmi pracova», je potrebné zní¾i» poèítadlo referencií uzla na ktorý ukazujú. Potom je mo¾né ukazateµ pou¾íva» u¾ µubovoµne.

Pred skonèením programu je nutné vola» funkciu \texttt{bddDestroy()}, ktorá uvoµní v¹etky alokované prostriedky. 

\subsubsection{Práca s~MTBDD}
Práca s~MTBDD je analogická ako práca s~BDD. V~podstate sa lí¹i iba v~tom, ¾e úplne na zaèiatku práce sa vytvárajú vlastné terminálne uzly pomocou funkcie \texttt{bddCreateTerminal()}. 

Ako uká¾ku som zvolil funkciu zo obrázka~\ref{picMTBDD}. Systém sa dá popísa» tabuµkou výsledných stavov uplatenia funkcie na jednotlivé terminály. tabuµka je nasledujúca: 
\begin{center}
  \begin{tabular}{|c|c c c c|}
    \hline
    $\mathit{func}(x,y)$ & $\mathit{S_{off}}$ & $\mathit{S_{on}}$    & $\mathit{S_{set}}$   & $\mathit{S_{count}}$  \\ 
    \hline
    $\mathit{S_{off}}$   & $\mathit{S_{off}}$ & $\mathit{S_{off}}$   & $\mathit{S_{off}}$   & $\mathit{S_{off}}$  \\ 
    $\mathit{S_{on}}$    & $\mathit{S_{off}}$ & $\mathit{S_{on}}$    & $\mathit{S_{set}}$   & $\mathit{S_{count}}$ \\ 
    $\mathit{S_{set}}$   & $\mathit{S_{off}}$ & $\mathit{S_{set}}$   & $\mathit{S_{set}}$   & $\mathit{S_{count}}$ \\ 
    $\mathit{S_{count}}$ & $\mathit{S_{off}}$ & $\mathit{S_{count}}$ & $\mathit{S_{count}}$ & $\mathit{S_{count}}$ \\ \hline
  \end{tabular}
\end{center}
Tabuµka zna¾í prechodovú funckiu ná¹ho systému. Implementácia pomocou kni¾nice je nasledujúca
\begin{lstlisting}
#include"bdd.h"

tBddNode * Son, *Soff, *Sset, *Scount;

tBddNode * func(tBddNode *x, tBddNode *y){
  if(x == y)                  return x;
  if(x == Soff || y == Soff)  return Soff;
  if(x == Son)                return y;
  if(y == Son)                return x;
  return Scount;
}

int main(){
  tManager mgr;
  tBddNode *xOnOff, *xSetCount, *tmp;
  
  bddInit(&mgr,BDD_SMALL);

  bddCreateTerminal(&mgr,"S_on",   &Son);
  bddCreateTerminal(&mgr,"S_off",  &Soff);
  bddCreateTerminal(&mgr,"S_set",  &Sset);
  bddCreateTerminal(&mgr,"S_count",&Scount);
  
  bddCreateNode(&mgr,"X_on_off",   Son, Soff,  &xOnOff);
  bddCreateNode(&mgr,"X_count_set",Scount,Sset,&xSetCount);
  
  tmp = bddApply(&mgr,xOnOff,xSetCount,func);
  nodeDecRef(&mgr,xOnOff);
  nodeDecRef(&mgr,xSetCount);
  
  printTree(&mgr,tmp);
  
  bddDestroy(&mgr);
}
\end{lstlisting}
Z~priestorových dôvodov som odtranil o¹etrovanie chybových stavov funkcií \texttt{bddInit()} a~\texttt{bddCreateTerminal()}. Ako vidíme, práca s~MTBDD je veµmi podobná práci s~BDD, s~tým rozdielom, ¾e sami vytvárame terminálne uzly a~funkcie nad nimi.

\chapter{Testy}
V~tejto kapitole popí¹em ako bol balík testovaný.
\section{Uniky pamäti}
Dealokáciu v¹etkých dátových ¹truktúr súvisiacich s~BDD má nastarosti procedúra 
\begin{verbatim}bddDestroy(
    tManager *mgr). 
\end{verbatim}
Na testovanie pamäti som pou¾il nástroj \texttt{valgrind}\footnote{\url{http://valgrind.org/}.}. Testy sú zamerané hlavne na správnos» uvolòovania v¹etkých vyu¾ívaných zdrojov. Samozrejme \text{valgrind} automaticky kontroluje, èi nepracujeme s~neinicializovanými premennými alebo èi nesiahame do pamäti, kam prístup nemáme. Pokiaµ nebude povedané inak, v¹etky testy sa vykonávajú nad managerom inicializovaným na veµkos» \texttt{BDD\_SMALL}

\paragraph{Inicializácia} V~programe sa volá inicializácia managera pomocou funkcie \texttt{bddInit()} a~následne sa volá funkcia \texttt{bddDestroy()}, ktorá by mala korektne uvoµni» v¹etky alokované èasti pamäte. Zdrojový kód sa nachádza v~\texttt{./tests/m-init.c} a~spú¹»a sa pomocou príkazu \texttt{make m-init} v~koreòovom adresári.\\
\begin{verbatim}
$ make m-init
==24458== HEAP SUMMARY:
==24458==     in use at exit: 0 bytes in 0 blocks
==24458==   total heap usage: 10 allocs, 10 frees, 8,856 bytes allocated
==32244== All heap blocks were freed -- no leaks are possible
\end{verbatim}

\paragraph{Jednoduchá funkcia} Program inicializuje managera, a~vytvorí jednoduchú logickú funkciu o~3 logických premenných. Funkcia je nasledujúca $$f(a,b,c)=(\neg a~\wedge b)\vee(a\wedge \neg b \wedge \neg c).$$ Kód je ulo¾ený v~\texttt{./tests/m-simplyf.c} a~spú¹»a sa príkazom \texttt{make m-simplyf} v~koreòovom adresári.\\
\begin{verbatim}
$ make m-simplyf
==24458== HEAP SUMMARY:
==24458==     in use at exit: 0 bytes in 0 blocks
==32244==   total heap usage: 13 allocs, 13 frees, 8,904 bytes allocated
==32244== All heap blocks were freed -- no leaks are possible
\end{verbatim}


\paragraph{Zlo¾itá funkcia} Program inicializuje managera a~vykonáva nad ním nasledujúcu funkciu $$f(x_1\,\dots,x_{33})=(x_1\wedge \dots \wedge x_{33}),$$ Manager sa inicializuje na veµkos» 16. Tento test sleduje prácu s~novými blokmi pamäte a~s~cache. Kód je ulo¾ený v~\texttt{./tests/m-bigf.c} a~spú¹»a sa príkazom \texttt{make m-bigf}.\\
\begin{verbatim}
$ make m-bigf
==11659== HEAP SUMMARY:
==11659==     in use at exit: 0 bytes in 0 blocks
==11659==   total heap usage: 65 allocs, 65 frees, 30,544 bytes allocated
==11659== All heap blocks were freed -- no leaks are possible
\end{verbatim}

\paragraph{Zhrnutie testov zameraných na pamä»} Pri korektom pou¾ívaní, kni¾nica nemá problém s~alokáciou a~uvoµnovaním zdrojov, nespôsobuje úniky pamäte a~nespôsobuje neoprávnené prístupy do pamäti.





\chapter{Porovnanie s~kni¾nicou CUDD}
V~kapitole dochádza k~porovnaniu programov s~mnou implementovanou kni¾nicou pre prácu s~BDD a~programov s~kni¾nicou CUDD. Testy sú zamerané hlavne na porovnanie èasových nároèností základných operácií s~kni¾nicami. V¹etky testy boli vykonané nad ¹kolskom servri \texttt{merlin}. V¹etky jednotky sú uvádzané v~sekundách.


\section{Inicializácia}
Jedná sa o~inicializáciu managera. V~CUDD na to slú¾i funkcia \texttt{Cudd\_Init()}, v~na¹ej kni¾nici funkcia \texttt{bddInit()}. Dosiahnuté výsledky popisuje nasledujúca tabuµka:

\begin{table}[h]
  \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}

    \hline
    \multirow{2}{*}{Kni¾nica} & \multicolumn{5}{c|}{Meranie} & \multirow{2}{*}{Priemer} \\ \cline{2-6}
                      &  1  &  2  &  3  &  4  & 5  &                   \\ \hline
    CUDD          & $0.023532$ & $0.021655$ & $0.022248$ & $0.022790$ & $0.018378$ & 0.021721 \\ \hline
    BDD kni¾nica  & $0.000499$ & $0.000473$ & $0.000449$ & $0.000265$ & $0.000431$ & 0.000413 \\ \hline
  \end{tabular}
\end{table}

\paragraph{Zhrnutie} V~testoch inicializácie je výrazne rýchlej¹ia moja kni¾nica. To je spôsobené hlavne jednoduchos»ou mojej kni¾nice, teda nie je potreba alokova» rozsiahle ¹truktúry. 

\section{Procedúra apply}
Testy v~tejto èasti sú zamerané na rýchlos» jednorázoveho prevedenia procedúry apply nad dvoma funkciami reprezentovanými pomocou BDD. Nasledujúca tabuµka popisuje rýchlos» vykonania nasledujúcej funkcie $$f=f_1 \vee f_2,$$ kde $f_1=(x_1\wedge\dots\wedge x_{200})$ a~$f_2=(\neg x_1\wedge\dots\wedge\neg x_{200})$.

\begin{table}[h]
  \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Kni¾nica} & \multicolumn{5}{c|}{Meranie} & \multirow{2}{*}{Priemer} \\ \cline{2-6}
                      &  1  &  2  &  3  &  4  & 5  &                   \\ \hline
    CUDD          & $0.000470$ & $0.000509$ & $0.000259$ & $0.000450$ & $0.000246$ & 0.000387 \\ \hline
    BDD kni¾nica  & $0.000519$ & $0.000232$ & $0.000510$ & $0.000548$ & $0.000437$ & 0.000449 \\ \hline
  \end{tabular}
\end{table}

Výsledky majú len nepatrné rozdiely, preto som sa rozhodol roz¹íri» funkcie $f_1 a~f_2$ tvorí 1000 uzlov, teda $f_1=(x_1\wedge\dots\wedge x_{1000})$ a~$f_2=(\neg x_1\wedge\dots\wedge\neg x_{1000})$. Namerané výsledky popisuje nasledujúca tabuµka:

\begin{table}[h]
  \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Kni¾nica} & \multicolumn{5}{c|}{Meranie} & \multirow{2}{*}{Priemer} \\ \cline{2-6}
                      &  1  &  2  &  3  &  4  & 5  &                   \\ \hline
    CUDD          & $0.000650$ & $0.000603$ & $0.000618$ & $0.000713$ & $0.000619$ & 0.000641 \\ \hline
    BDD kni¾nica  & $0.000678$ & $0.000710$ & $0.000703$ & $0.000757$ & $0.000698$ & 0.000709 \\ \hline
  \end{tabular}
\end{table}

Po tomto teste je mo¾né poveda», ¾e kni¾nica CUDD je rýchlej¹ia. Výpoèet bol v¹ak v~oboch prípadoch veµmi rýchly, preto následujúce testy merajú dobu trvania celého programu bez inicializácie a~uvoµnenia.

\section{Då¾ka programu}
V~tejto èasti sú testy zamerané na celkovú dl¾ku programu pri vytváraní zlo¾itej¹ích funkcií. Testy merajú celú dobu behu programu s~výnimkou inicializácie a~uvoµnovania managera, lebo v~kni¾nici CUDD sú tieto operácie veµmi nároèné a~mohli by skreslova» porovnanie rýchlostí procedúry apply.

Funkcia ktorú v~programe vytvoríme je $$f=(x_1\wedge\dots\wedge x_4)\oplus(x_2\wedge\dots\wedge x_5)\oplus\dots\oplus(x_{22}\wedge\dots\wedge x_{25}),$$ kde $\oplus$ znaèí logickú operáciu xor. Namerané výsledky sú v~nasledujúcej tabuµke:

\begin{table}[h]
  \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Kni¾nica} & \multicolumn{5}{c|}{Meranie} & \multirow{2}{*}{Priemer} \\ \cline{2-6}
                      &  1  &  2  &  3  &  4  & 5  &                   \\ \hline
    CUDD          & $0.001229$ & $0.001163$ & $0.001143$ & $0.001175$ & $0.001187$ & 0.001179 \\ \hline
    BDD kni¾nica  & $2.230097$ & $1.785477$ & $1.778962$ & $1.938497$ & $1.962328$ & 1.939072 \\ \hline
  \end{tabular}
\end{table}

Je vidie», ¾e mnou implementovaná kni¾nica nestíha pri vy¹¹ích výpoètoch. Zrejme to bude zapríèinené slabou optimalizáciou výpoètov a~nevhodnou ¹truktúrou ukladania medzivýsledkov.

\chapter{Záver}
Práca sa venuje návrhu a~implementácií kni¾nice pracujúcej s~binárnymi rozhodovacími diagramami BDD. Hlavným prínosom práce je je poskytnutie jednej z~mo¾ných reprezentacií efektívneho ulo¾enia BDD v~poèítaèi. Návrh sa zameriava hlavne na zní¾enie poètu alokácií. Práca je implementovaná v~jazyku C.

V~práci sa nachádza matematický popis výrokovej logiky, ktorý je neodeliteµnou súèas»ou popisu BDD. Ïalej je popísané BDD pomocou formálneho matematického zápisu ako acyklický spojitý orientovaný koreòový graf. V~práci sú popísané taktie¾ multiterminálne BDD: MTBDD. Práca obsahuje algoritmy na zní¾enie pamä»ovej nároènosti BDD v~poèítaèi. Ïalej je tu popísaný algoritmus funkcie \emph{apply}. V~práci sú taktie¾ popísané niektoré existujúce balíky pre prácu s~BDD.

Implementácia pre¹la sadou testov, ktoré mali odhali» prípadné úniky pamäte a~neoprávnené prístupy do pamäti. Kni¾nica vyhovela v¹etkým testom. Ïalej bola kni¾nica testovaná výkonnostnými testami a~porovnávaná s~kni¾nicou CUDD. V~teste inicializácie a~uvoµnovania managera moja kni¾nica výrazne predbiehala kni¾nicu CUDD, èo mô¾e by» spôsobené jednoduch¹iou ¹truktúrou návrhu. V~testoch ohµadom porovnania funkcie \emph{apply} moja kni¾nica výrazne zaostávala za CUDD. Programom \texttt{gprof}\footnote{\url{http://www.cs.utah.edu/dept/old/texinfo/as/gprof_toc.html}} som zistil, ¾e a¾ pätinu èasu program strávil prehµadávanim medzivýsledkov.

Návrhy roz¹írenia práce do budúcna sú:
\begin{itemize}
  \item podpora MTBDD aby bolo mo¾né pracova» aj s~nekoneènými doménami,
  \item prerobenie ¹truktúry medzivýsledkov na zní¾enie èasovej nároènosti programov,
  \item vstupný prekladaè pre naèítanie BDD zo súboru,
  \item výstupný prekladaè pre zápis BDD do súboru v~nejakom pou¾iteµnom formáte.
\end{itemize}

Dosiahnuté výsledky urèujú kni¾nicu skôr na ïal¹í vývoj a~prípadnú demon¹tráciu práce s~BDD a~nie na praktické nasadenie.