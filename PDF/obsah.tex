\chapter{Úvod}
V mnohých oblastiach informatiky je potrebné efektívne pracova» s funkciami nad binárnimi premennými. Mô¾e ís» napríklad o efektívnu reprezentáciu hardwarových komponént pri návrhu logických obvodov, reprezentáciu veµkých matíc v matematických knihovniach alebo o reprezentáciu stavového priestoru vo formálnej verifikácií. Existuje niekoµko prístupov pre repzrezentáciu týchto funkcií, prièom jedným z najpou¾ívanej¹ích sú binárne rozhodovacie diagramy(BDD).

BDD reprezentuje funkciu nad binárnimi premennými kompaktne pomocou koreòového acyklického orientovaného spojitého grafu. Nad týmto grafom sa dajú uplatòova» mnohé algoritmy, ktoré zni¾ujú jeho pamä»ovú aj èasovú nároènos».

Úèelom práce je navrhnú» a implementova» vlastnú kni¾nicu pre prácu s BDD. Práca demon¹truje základné princípy algoritmov uplatnených nad BDD, mo¾nosti reprezentácie BDD v poèítaèi a súèas»ou je taktie¾ porovnanie dosiahnutých výsledkov s niektorými kni¾nicami.

Práca obsahuje v kapitole \ref{kap:logika} formálny popis výrokovej logiky, v kapitole \ref{kap:bdd} typy BDD, prevod binárneho rozhodovacieho stromu BDT na BDD, základný princíp procedúry apply a popis MTBDD. V kapitole \ref{kap:baliky} popí¹eme niektoré existujúce balíky pre prácu s BDD a MTBDD. Zvy¹ná èas» práce obsahuje popis návrhu, implementácie a testovania kni¾nice. Záver práce patrí zrovnaniu výsledkov s kni¾nicou CUDD.





\chapter{Výroková logika} \label{kap:logika}

Výroková logika skúma spôsoby tvorby zlo¾ených výrokov z jednoduchých a pravdivos» (nepravdivos») zlo¾eného výroku v závislosti od pravdivosti jednoduchých z ktorých je zlo¾ený. Celá kapitola o výrokovej logike je prevzaná z literatúry\cite{Slapal}.

Buï $P$ neprázdna mno¾ina prvotných formúl, ktoré hrajú úlohu jednoduchých výrokov. Z jednoduchých výrokov získaváme zlo¾ené výroky spájaním pomocou logických spojok. Poznáme nasledujúce logické spojky:
\begin{itemize}
  \item{$\neg$ negácia}
  \item{$\vee$ disjunkcia}
  \item{$\wedge$ konjunkcia}
  \item{$\rightarrow$ implikácia}
  \item{$\equiv$ ekvivalencia}
\end{itemize}

Symbolmi jazyka $L_P$ výrokovej logiky nad mno¾inou $P$ sú prvky mno¾iny $P$, logické spojky a zátvorky (,). Skladanie zlo¾ených výrokov sa riadí týmito pravidlami:
\begin{enumerate}
  \item Ka¾dá prvotná formula $p\in P$ je výroková formula.
  \item Pokiaµ sú $A$, $B$ výrokové formule, potom ($\neg A$),($A\vee B$),($A\wedge B$),($A\rightarrow B$) a ($A\equiv B$) sú výrokové formule.
  \item Ka¾dá výroková formula je poskladaná koneèným poètom symbolov jazyka $L_P$, ktorá vznikne podµa predchádzajúcich pravidiel.
\end{enumerate}

Pravdivostné ohodnotenie prvotných formulí je µubovoµné zobrazenie mno¾iny $P$ na hodnoty {\it true} a {\it false}. Pre jednoduchos» budeme znaèi» {\it true} 1 a {\it false} 0. Formálny zápis je $v:P\rightarrow\{0,1\}$. Indukciou podµa zlo¾itosti formule definujeme rozlo¾enie $w$ na zobrazenie $v$ na mno¾inu v¹etkých formulí jazyka $L_P$.
\begin{enumerate}
  \item $w(p)=v(p)$ pre v¹etky $p\in P$
  \item pokiaµ $A$, $B$ sú výrokové formule, potom $w(\neg A)$, $w(A\vee B)$, $w(A\wedge B)$, 
  $w(A\rightarrow B)$ a~$w(A\equiv B)$  v závistosti od $w(A)$ a~$w(B)$ sa definujú podµa nasledujúcej tabuµky:
\end{enumerate}

\begin{center}
  \begin{tabular}{|c|c||c|c|c|c|c|}
    \hline
    $w(A)$ & $w(B)$ & $w(\neg A)$ & $w(A\vee B)$ & $w(A\wedge B)$ &
    $w(A\rightarrow B)$ & $w(A\equiv B)$ \\
    \hline
    0 & 0 & 1 & 0 & 0 & 1 & 1 \\ 
    0 & 1 & 1 & 1 & 0 & 1 & 0 \\ 
    1 & 0 & 0 & 1 & 0 & 0 & 0 \\ 
    1 & 1 & 0 & 1 & 1 & 1 & 1 \\ \hline
  \end{tabular}
\end{center}

\section{Mo¾nosti reprezentácie funckií}
Logické funkcie sa mô¾u reprezentova» rôznymi spôsobmi. Najèastej¹ie vyjadrenie je v podobe matematického vzorca za pomoci vy¹¹ie spomínaných operátorov a funckií. Ma» v¹ak v poèítaèi funkciu ulo¾enú ako textový re»azec veµmi komplikuje prácu s òou, preto sa vyvynuli rôzne dal¹ie reprezentácie. Operátory logických funckií sa väè¹inou prevádzajú po rade z $\vee, \wedge, \neg$ na $+, *, !$.

\paragraph{Pravdivostná tabuµka} Najprehµadnej¹í a najµah¹ie nauèiteµný typ uchovávania logickej funkcie, bohu¾ial obsahuje veµké mno¾stvo redundancie a mô¾e ma» veµké pamä»ové nároky ($2^n$, kde $n$ je poèet premenných funkcie).
\paragraph{Logický obvod} Nie moc prehµadný ani µahko nauèiteµný formát, ale vynikajúcí na demo¹tráciu pokroèilých systémov zlo¾ených z logických funkcií.
\paragraph{BDD} Formát v podobe acyklického koreòového grafu, ktorému sa budeme ïalej venova» v kapitole \ref{TypyBDD}.

\section{Minimalizácia}
Minimalizácia logickej funkcie je proces zni¾ovania pamä»ových nárokov funkcie odstránením redundancie. V prípade matematického popisu mô¾e ís» o uplatnenie rôznych výrokových teorémov a viet. Podrobnéj minimalizácií BDD sa budeme venova» v kapitole \ref{TypyBDD}.

\section{Poèet funkcií}\label{logfce}
Poèet mo¾ných správaní sa logickej funkcie závisí od poètu premenných, ktoré ju ovplyvòujú a poètu hodnôt, ktoré ka¾dá premenná mô¾e nadobudnú». Ide o jednoduchú kombinatoriku, kde zis»ujeme v¹etky variacie vstupných hodnôt, teda $p=n^k$, kde $n$ je poèet hodnôt, ktoré mô¾e nadobúda» vstupná premenná, $k$ poèet vstupných premenných a $p$ je výsedny poèet mo¾ných vstupov funkcie.

Výsledný poèet funkcií je permutácia závisiaca od poètu mo¾ných vstupných kombinácií a poètu hodnôt, ktoré mô¾e nadobúda» výstup funkcie, teda $r=q^p$, kde $p$ je poèet vstupných kombinácií, $q$ je poèet hodnôt, ktoré mô¾e výstpná premenná nadobúda» a $r$ je poèet funkcií danej funkcie. Z tohto dostávame vzorec
\begin{equation}
  r=q^{n^{k}}.
\end{equation}
Názornej¹ie vyjadrenie poètu logických funckií je pomocou tabuµky pre dve vstupné premenné ($k$=2), dve vstupné hodnoty ($n$=2) a dve výstupné hodnoty ($q$=2) $\rightarrow 2^{2^2}=16$ funkcií\\

\begin{center}
  \begin{tabular}{|c|c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multicolumn{2}{|c||}{Vstup}&\multicolumn{16}{c|}{Výstup} \\ \hline
    % x & y  \\ \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
    0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ \hline
    1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ \hline
    1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\ \hline
  \end{tabular}
\end{center} 






\chapter{Binárne rozhodovacie diagramy} \label{kap:bdd}
V tejto kapitole popí¹eme históriu BDD, BDD ako matematický formalizmus a transformovanie BDD na redukované usporiadané BDD\,--\,ROBDD.

\section{História}
BDD vznikli z~dôvodu úspornej¹iej reprezentácie logických funckií. Reprezentácia je navrhnutá na základe Shanonovho expazného teorému\cite{Shannon}. Táto dátová ¹truktúra od vzniku v~1959\cite{Lee} pre¹la mnohými úpravami na zní¾enie èasovej a~pamä»ovej nároènosti.

Najvýznamnej¹ím milníkom v~oblasti redukcie pamä»ovej nároènosti bola ¹túdia R. E. Bryanta\cite{Bryant} z~Univerzity Carnegie Mellon. Táto ¹túdia sa týka najmä poradia premenných a~zdieµania podgrafov. Toto sa dá poklada» za vznik ROBDD popísaných v~sekcií \ref{ROBDD}.


\section{Matematický popis}
Prevzaté z predná¹ky \cite{Vojnar}.

BDD je reprezentácia logickej funkcie $\{0,1\}^k\rightarrow\{0,1\},k\geq 0$. Z pohµadu teorie grafov sa jedná o koreòový, orientovaný, spojitý acyklický graf. Formálna definícia BDD $G$ nad mno¾inou premenných $M$ je
\begin{equation} \ref{bdd:formal} 
  G=(N,T,var,low,high,root,val),
\end{equation}
kde 
\begin{itemize}
  \item $N$ je koneèná mno¾ina neterminálnych stavov (uzlov).
  \item $T$ je koneèná mno¾ina terminálnych stavov (listov), $N\cap T=\emptyset$.
  \item $var \colon N\rightarrow M$ je interné pomenovanie uzlov.
  \item $low, high \colon N\rightarrow N\cup T$ funkcia následníkov, definujúca vysokého a nízkeho následníka pre daný úzol $n\in N$ pre premennú $var(n)$ so vstupom $0$ alebo $1$.
  \begin{itemize}
    \item graf je acyklický teda $\neg \exists n \in N.n(low\cup high)^+n$.
  \end{itemize}
  \item $root \in N\cup T$ je koreò grafu, teda $\forall n \in (N\cup T)\backslash\{root\}.root(low\cup high)^+n$. Vstupné hrany do uzlú $root$ by poru¹ili acyklicitu grafu.
  \item $val \colon T\rightarrow \{0,1\}$ je mapovacia funkcia hodnôt terminálnych uzlov
\end{itemize}

\section{Procedúra \emph{Apply()}} \label{apply}
Procedúra \emph{Apply()} aplikuje booleovskú funkciu na BDD. Obecne mô¾e by» $k$-árna. V takom prípade dostáva procedúra $k$ diagramov a funkciu, ktorú má nad diagramami vykona». Výsledkom procedúry je jedno BDD. 

Základný princíp funkcie je odvodený z Shannonovho expandného teorému, ktorý je popísaný v literatúre\cite{Shannon}. Ide o restrikciu urèitej premennej v grafe za konkrétnu hodnotu. Nech je $n$-parametrová funkcia $f(v_1,\dots,v_n)$. Vykonanie restrikcie nad funkciou $f$, premennej $v_i$ za hodnotu $a$ dostávame funkciu $f(v_1,\dots,v_{i-1},a,v_{i+1},\dots,v_n)$, skrátene písané $f|_{v_i\leftarrow a}(v_1,\dots,v_n)$. Pokiaµ prevedieme restrikciu na v¹etky premenné, výsledok konrétneho dotazu nad funkciou u¾ nie je rozhodovacia funkcia ale konkrétna hodnota. Podµa Shannonovho torému platí 
$$f(v_1,\dots v_n)=(\neg v_1\wedge f|_{v_i\leftarrow 0}(v_1,\dots,v_n))\vee(v_1\wedge f|_{v_i\leftarrow 1}(v_1,\dots,v_n)).$$
Buï $f_1,\dots,f_k$ $k$ funkcií nad rovnakou doménou premenných a $op()$ $k$-árny operátor nad BDD. Operátor $op()$ vykonáva restrikciu nad v¹etkými funkciami nasledovne: 
$$op(f_1,\dots,f_k)=(\neg v\wedge op(f_1|_{v\leftarrow 0},\dots,f_k|_{v\leftarrow 0}))\vee(v\wedge op(f_1|_{v\leftarrow 1},\dots,f_k|_{v\leftarrow 1})).$$

Restrickia sa pri tvorbe BDD pomocou funkcie $f$ vyu¾íva pre ka¾dý uzol $n$ nasledovne:
\begin{itemize}
  \item $low(n)=\neg n \wedge f|_{n\rightarrow 0}$
  \item $high(n)=n \wedge f|_{n\rightarrow 1}$
  \item $f(n)=high(n)\vee low(n)$
\end{itemize}

Postupným zanorovaním restrikcie vzniká rekurzívny algoritmus popísaný v algoritme \ref{algApply}. Operátor $a\prec b$ znaèí, ¾e premenná $a$ sa nachádza bli¾¹ie ku koreòu ako premenná $b$.
\begin{algorithm}[h]
  \caption{Apply} \label{algApply}
  \SetAlgoLongEnd
  \LinesNumbered
  \SetNlSty{normal}{}{:}
 
  \KwIn{$X,Y\in N\cup T,\mathit{func}$ je funkcia nad terminálnymi uzlami BDD}
  \KwOut{$\mathit{result}$ je výsledok funkcie $\mathit{func}(X,Y)$}
\medskip
  $xh = X$, $xl = X$, $yh = Y$, $yl = Y$\;
  \eIf{($X,Y\in T$)}{
    \Return $\mathit{func}(X,Y)$ \;
  }{
    \eIf{($X\prec Y$)}{
      Vytvor uzol podµa $\mathit{var(X)}$\;
      $xh=high(X)$, $xl=low(X)$\;
    }{
      \eIf{($Y\prec X$)}{
        vytvor uzol podµa $\mathit{var(Y)}$\;
        $yh=high(Y)$, $yl=low(Y)$
      }{
        vytvor uzol podµa $\mathit{var(Y)}$\;
        $xh=high(X)$, $xl=low(X)$, $yh=high(Y)$, $yl=low(Y)$\;
      }
    }
  }
  $\mathit{result.high=Apply(xh,yh,\mathit{func})}$\;
  $\mathit{result.low=Apply(xl,yl,\mathit{func})}$\;
  \medskip
  \eIf{$(\mathit{low(result)=high(result)})$}{
    $\mathit{result=low(result)}$\;
  }{
    \If{$(\mathit{result}$ je v $\mathit{cache})$}{
      uvolni $\mathit{result}$\;
      $\mathit{result}=$ cache zaznam\;
    }
  }
  \medskip
  \Return $\mathit{result}$\;
\end{algorithm}


\section{Typy BDD}\label{TypyBDD}
V tejto kapitole si popí¹eme niektoré základné typy BDD, zdôrazníme rozdiely medzi nimi a objasníme, v èom sú niektoré efektívnej¹ie ako iné. Základné princípy budeme demon¹trova» na funkcii

\begin{equation}
  f(x_1,x_2,x_3)=(\neg x_1\wedge \neg x_2 \wedge \neg x_3)\vee(x_1\wedge \neg x_2\wedge \neg x_3)\vee(x_1\wedge x_2\wedge \neg x_3).
\end{equation}

V texte budeme pou¾íva» nasledujúcu notáciu
\begin{itemize}
  \item Premenné sa znaèia $x_i$, kde $i$ je poradie premennej.
  \item Uzly sa znaèia písmenom $n_{ij}$, kde $i$ je index premennej a $j$ je poradové èíslo uzlu oznaèovaného premennou.
\end{itemize}
Príklad: $n_{23}$ znaèí tretí uzol premennéj $x_2$.


\subsection{BDT}\label{ROBDD}
Binárny rozhodovací strom sa vytvára ako koreòový graf. Koreò tvorí jedna z premenných, väè¹inou sa berie prvá premenná funkcie, teda v na¹om prípade $x_1$. Vytvoríme teda uzol $n_{11}$, ktorý je mapovaný na premennú $x_1$. Premenná mô¾e nadobúda» dvoch hodnôt, pre ktoré sú definované nasledujúce uzly mapované na nasledujúcu premennú (uzly $n_{21}$ a $n_{22}$ mapované na premennú $x_2$). Takto sa postupne zanorujeme, a¾ prejdeme cez v¹etky premenné a vygenerujeme v¹etky potrebné uzly. Hodnoty priradené za uzly mapované na poslednú premennú sú terminálne uzly. Poèet generovaných uzlov je 
\begin{equation} \label{pocetUzlov}
  \sum_{i=0}^{k} 2^i,
\end{equation}
kde $k$ je poèet premenných.

Grafické znázornenie na¹ej funkcie je na obrázku \ref{picBDD}.
\begin{figure}[ht!]
  \includegraphics[bb=0 50 0 200]{fig/bdd1.eps}
  \caption{Základné BDD}
  \label{picBDD}
\end{figure}

\paragraph{Notácia}
Pre orientáciu v grafe je pou¾itá nasledujúca notácia
\begin{enumerate}
  \item Uzly
    \begin{itemize}
      \item Znaèené krú¾kom.
      \item Hierarchicky usporiadané podµa poradia vyhodnocovania.
      \item Premenná ovplyvòujúca uzol je písaná vµavo.
    \end{itemize}
  \item Terminály
    \begin{itemize}
      \item Znaèené ¹tvorèekom.
      \item Symbol $\perp$ znaèí hodnotu $false$.
      \item Symbol $\top$ znaèí hodnotu $true$.
    \end{itemize}
  \item Hrany
    \begin{itemize}
      \item Plná èiara vedie k vysokému následníkovi daného uzlu $high(n)$.
      \item Preru¹ovaná èiara vedie k nízkemu následníkovi daného uzlu $low(n)$.
    \end{itemize}
\end{enumerate}

Ako vidíme, pre 3 premenné je poèet generovaných uzlov 15, èo je exponencialna zlo¾itos», èím je potvrdená rovnica \ref{pocetUzlov}. Zlo¾itos» najdenia daného terminálneho uzlu je lineárna vzhµadom k poètu premenných. Táto reprezentácia obsahuje mnoho redundancie, preto sa nepou¾íva.

\subsection{Redukované BDD}
Poèet generovaných uzlov sa dá výrazne obmedzi» tým, ¾e sa nebudú generova» zbytoèné uzly. Pri pohµade na obrázok \ref{picBDD} vidíme redundanciu v terminálnych uzloch. Terminálne uzly mô¾eme zlúèi» do dvoch. Vzniká diagram s redukovaným poètom terminálnych uzlov, ktorý je znázornený na obrázku \ref{picRBDD1}.

\begin{figure}[ht!]
  \includegraphics[bb=0 0 0 200]{fig/bdd2.eps}
  \caption{BDD s redukovaným poètom terminálnych uzlov}
  \label{picRBDD1}
\end{figure}

Ïal¹iou redukciou je zluèovanie izomorfných podgrafov. Keï sa v BDD nachádzajú dva rôzne uzly, ktoré majú rovnaké (izomorfné) podgrafy, mô¾eme ich zlúèi» do jedného.

\paragraph{Graf} je definovaný ako dvojica $G=(V,H)$, kde $V$ je mno¾ina vrcholov a $H$ je mno¾ina hrán typu $(v_1,v_2)$ kde $v_1,v_2 \in V$, teda $H\subseteq V^2$.
\paragraph{Izomorfizmus} dvoch grafov $G_1=(V_1,H_1)$ a $G_2=(V_2,H_2)$ je definovaný vzájomne bijektívne zobrazenie $f:V_1\rightarrow V_2$ a $g:H_1\rightarrow H_2$ také, ¾e µubovoµnej hrane $h\in H_1$ sú priradené vrcholy $x,y\in V_1 \Leftrightarrow$ hrane $g(h)\in H_2$ sú priradené vrcholy $f(x),f(x)\in V_2$.\\Pokiaµ grafy $G_1$ a $G_2$ sú izomorfné, teda existujú funkcie $f$ a $g$, potom pí¹eme $G_1 \otimes G_2$.

Strom s odstránenými izomorfnými podstromamy je na obrázku \ref{picRBDD2}.

\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd3.eps}
  \caption{BDD s odstránenými izomorfnými podstromami}
  \label{picRBDD2}
\end{figure} 

Ïal¹iou redukciou je vynechávanie uzlov, kde $low(n) = high(n),pre\ n\in N$. Ak sa vysoký aj nízky následník odkazujú na izomorfné podgrafy, logická funkcia v tomto bode nezávisí od danej premennéj, preto sa mô¾e tento uzol vynecha». Výsledný strom je na obrázku \ref{picRBDD3}.

\begin{figure}[ht!]
  \includegraphics[bb=0 40 0 250]{fig/bdd4.eps}
  \caption{Výsledné minimalizované BDD}
  \label{picRBDD3}
\end{figure}

\paragraph{RBDD} je klasické BDD, pre ktoré platia nasledujúce pravidlá:
\begin{enumerate}
  \item $\neg\exists n\in N.low(n)=high(n)$
  \item $\neg\exists x_1,x_2\in N \cup T.x_1=x_2\wedge Root(G_1)=x_1\wedge root(G_2)=x_2 \wedge G_1 \otimes G_2$
\end{enumerate}


\subsection{Redukované usporiadané BDD} 
Poradia vyhodnocovania premenných, ktoré ovplyvòujú uzly, majú veµký vplyv na poèet generovaných uzlov. Pre ilustráciu si to predveïme na funkcií
\begin{equation}
  y(x_1,...,x_8) = (x_1 \wedge x_2)\vee(x_3 \wedge x_4)\vee(x_5 \wedge x_6)\vee(x_7 \wedge x_8).
\end{equation}
RBDD odpovedajúce danej funkcie je na obrázku \ref{picROBDD}.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=150mm]{fig/bdd5.jpg}
  \caption{Rozdiel medzi dobrým a zlým usporiadaním\cite{WikiOrder}}
  \label{picROBDD}
\end{figure}
\par
Obe BDD sú minimalizované a popisujú rovnakú logickú funckiu. Z pravého obrázku v¹ak vidíme, ¾e dobrým usporiadaním výrazne zní¾ime poèet generovaných uzlov. Na zistenia optimálneho usporiadania v¹ak neexistuje doposiaµ ¾iadný efektívny algoritmus. Jedná sa o NP-nároèný problém. Existujú iba rôzne heuristiky. Tie nám v¹ak mô¾u pomôc», teda dostaneme výsledný strom s men¹ím poètom uzlom, ale aj u¹kodi». Tu je zoznam niektorých pou¾ívaných algoritmov:

%BDD-dip
\textbf{Náhodný algoritmus}\cite{Rucky} Algoritmus sa pou¾íva v dvoch variantách a to varianta s pivotom a varianta bez pivota.\\Varianta bez pivota vyberá dve náhodné premenné v grafe a tie vymení postupným vymieòaním susedných uzlov. Výsledné usporiadanie premenných pre danú iteráciu je ulo¾enie s najmen¹ím poètom uzlov v priebehu itérácie. \\ Varianta s pivotom pracuje na rovnakom princípe, ale pred samotným algoritmom sa vyberie pivot. To je premenná s najvy¹¹ím poètom uzlov. Dve náhodne zvolené premenné sú také, ¾e jedna sa nachádza nad a druhá pod pivotom. 

\textbf{Sifting algoritmus} \cite{Rudell} Teória je spoèíta» najvýhodnej¹iu pozíciu v grafe pre jednu premennú s tým, ¾e ostatné premenné zachovajú svoje poradie. Premennú posúvame najskôr smerom k terminálnym uzlom, potom smerom ku koreòu. Po príchode do koreòu vieme, v ktorej pozícií mala premenná najmenej uzlov a posunieme ju tam. Posun sa vykonáva na základe prehadzovania susedných premenných.

Iné pou¾ívané algoritmy sú napríklad
\begin{itemize}
  \item{Symmetric sifting algoritmus}
  \item{Group sifting algoritmus}
  \item{Window permutation algoritmus}
  \item{Algoritmus vyu¾ívajúci genetické algoritmy}
\end{itemize}

\section{Multiterminálne BDD}
Formálna definácia MTBDD je rovnaká ako definiícia \ref{bdd:formal} pre BDD s rozdielom, ¾e v MTBDD mno¾inu $\mathit{val}$ definujeme takto:
\begin{itemize}
  \item $\mathit{val} \colon T \rightarrow \mathds{D}$, kde $\mathds{D}$ je potenciálne nekoneèná mno¾ina.
\end{itemize}

Multiterminálne BDD sú vo svojej podstate obyèajné ROBDD, ktoré majú väè¹í, obecne neobmedzený poèet terminálnych uzlov. Ako príklad si mô¾eme uvies» kombinaèný systém\footnote{Stav závisí iba na kombinácii vstupu}, ktorý sa mô¾e nachádza» v stavoch $S_{\mathit{off}}$, $S_{set}$ a $S_{count}$. Vstupné premenné sú $X_{on}$ a $X_{count}$. Tabuµka systému je 
\begin{center}
  \begin{tabular}{|c|c||c|}
    \hline
    $X_{on}$ & $X_{count}$ & $S(X_{on}, X_{count})$ \\ \hline
    0 & 0 & $S_{\mathit{off}}$ \\ \hline
    0 & 1 & $S_{\mathit{off}}$ \\ \hline
    1 & 0 & $S_{set}$ \\ \hline
    1 & 1 & $S_{count}$ \\ \hline
  \end{tabular}
\end{center}

Na miminalizáciu MTBDD sa dajú pou¾i» opä» pou¾i» obe techniky, teda odstránenie izomorfných podstromov a uzlov, kde $\mathit{high}(x)=\mathit{low}(x)$. Podµa tabuµky jednoducho zostrojíme a zminimalizujeme BDD, ktoré v¹ak nemá iba 2 terminálne hodnoty ale 3. 

\begin{figure}[ht!]
  \includegraphics[bb=-100 0 0 250]{fig/bdd6.eps}
  \caption{Príklad MTBDD}
  \label{picMTBDD}
\end{figure}



  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Porovnání dostupných programových balíkù pro manipulaci
% s binárními rozhodovacími diagramy, Martin Felcman, BP, 2008
% felcmm1_2008bach.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dostupné balíky} \label{kap:baliky} 
V tejto kapitole si popí¹eme niektoré kni¾nice pracujúce s BDD. Bude popísaná ¹truktúra uzlu a spôsob práce s diagramami.

\section{CUDD}
Balíèek bol vyvíjaný na univerzite v Coloradu. U¾ od roku 1996 stálym vývojom dosiahol vynikajúce pamä»ové a výkonnostné výsledky. Podporuje prácu s BDD, Aritmetickými rozhodovacími diagramami ADD a diagramami s potlaèenou nulou ZDD. V kni¾nici je taktie¾ implementovaná sada algoritmov na zlep¹enie usporiadania premenných. Balíèek sa mô¾e pou¾íva» 3 spôsobmi:
\begin{enumerate}
  \item {Black box}\,--\,Umo¾òuje pou¾íva» iba exportované funkcie popísané v nápovede.
  \item {Clean box}\,--\,Umo¾nuje písanie zlo¾itej¹ích projektov, kde je vzhµadom k efektivite nutné prida» do balíka vlastné funkcie.
  \item {Interface}\,--\,Balík disponuje kvalitne spracovaním rozhraním pre prácu s BDD ako objektami.
\end{enumerate}
Podrobná definícia celého balíka CUDD je popísaná v literatúre\cite{cudd}.

\subsection{©truktúra uzlu}
\begin{lstlisting}
struct DdNode{
  DdHalfWord index;
  DdHalfWord ref;
  DdNode *next;
  union{
    CUDD_VALUE_TYPE value;
    DdChildren kids;
  } type;
};
\end{lstlisting}
©truktúra reprezentuje terminálne aj neterminálne uzly. Na zistenie, èi konkrétny uzol je terminálny slú¾i makro \texttt{Cudd\_IsConstant()}. V premennej \texttt{index} je ulo¾ený názov premennej, podµa ktorej je pomenovaný uzol. Odrá¾a poradie vzniku uzlov. V premennej \texttt{ref} je poèítadlo referencií na uzol. Premenná \texttt{next} ukazuje na daµ¹í uzol v unique table. Ak ide o terminálny uzol, obsahuje premennú \texttt{value}, ktorá znaèí hodnotu uzlu, ináè obsahuje ¹truktúru \texttt{kids}, kde sú ulo¾ené ukazatele na vysokého a nízkeho následníka daného uzlu. 
\\
\subsection{Manager}
V¹etky pou¾ité uzly sú ulo¾ené v ¹pecialnej hashovaciej tabuµke (unique table). BDD a ADD zdieµajú rovnakú tabuµku, ZDD má svoju vlastnú. Manager sa pred pou¾itím inicializuje funkciou \texttt{Cudd\_Init()} a po pou¾ití ru¹í funckiou \texttt{Cudd\_Quit()}.

\subsection{Zhrnutie}
CUDD je univerzálny balíèek pre prácu s BDD. Má kvalitne spracovanú dokumentáciu vèetne u¾ivateµského a programátorského manuálu. Výhodou je disponovanie ¹irokou ¹kálou funkcií pre radenie poradia premenných. 



\section{BuDDy}
Táto kni¾nica bola vytvorená ako súèas» dizertaènej práce. Spoèiatku bola urèená len na demo¹tráciu princípov BDD. Vo svojej poslednej verzií je u¾ v¹ak plnohodnotným balíkom so v¹etkými ¹tandartnými operáciami, radením poradia premenných a dokumentáciou.

\subsection{©truktúra uzlu}
\begin{lstlisting}
typedef struct s_BddNode{
  unsigned int refcou : 10;
  unsigned int level : 22;
  int low;
  int high;
  int hash;
  int next;
} BddNode;
\end{lstlisting}

Je potrebné uvies», ¾e BuDDy nepracuje s managerom ale s poµom uzlov, preto v¹etky premenné, ktoré odkazujú nejaký uzol sú reprezentované ako index do tohto poµa.

Premenná \texttt{refcou} obsahuje poèet referencií vedúcich na uzol. Premenná \texttt{level} ukazuje pozíciu premennéj pri súèastnom ulo¾ení. Premenné \texttt{high} a \texttt{low} reprezentujú hrany, \texttt{next} je ukazateµ na nasledujúci uzol. Premenná \texttt{hash} je ukazateµ na koreò stromu.
\\
\subsection{Zhrnutie}
BuDDy je kompletný balík na prácu s BDD. Podporuje usporiadavanie premenných. BuDDy má veµmi kvalitne spracované C\verb!++! rozhranie, ktoré zefektívòuje prácu s týmto balíkom.


\section{CacBDD}
Jedná sa o kni¾nicu vyvýjanú v jazyku C\verb!++!, ktorá je podobne ako BuDDy zalo¾ená na indexovaní v poli. Podporuje obvyklé operátory vyu¾ívané v modelcheckingu. CacBDD má kvalitne spracované ukµadanie medzivýsledkov, vïaka èomu dosahuje výborné èasové výsledky.

Kni¾nica je veµmi jednoducho popísaná v literatúre\cite{cacbdd}. Ja som potrebné informácie nachádzal priamo v zdrojových súboroch dostupných z \url{http://www.kailesu.net/CacBDD/CacBDD.zip}.

\subsection{©truktúra uzlu}
\begin{lstlisting}
class DdNode{
  public:
    int var;     
    int Then;
    int Else;
    int Next;
    
    // metody
}
\end{lstlisting}

Jeden uzol je ulo¾ený v triede \texttt{DdNode}. Táto ¹truktúra je ulo¾ená v poli, preto sú odkazy typu \texttt{int} a reprezentujú index do tohto poµa. \texttt{var} znaèí index premennej, \texttt{Then} a \texttt{Else} sú indexy následníkov a \texttt{Next} obsahuje index následujúcej voµnej premennej.

Súèas»ou triedy sú aj metody na vytvorenie objektu, jeho zru¹enie a nastavenie hodnôt.
\\
\subsection{Medzivýsledky}
V CacBDD slú¾i na ukladanie medzivýsledkov ¹truktúra \texttt{XCTable}, ktorá sa dynamicky mení v závislosti od tzv. \texttt{hit-rate}, èo¾ je pomer zásahov do tabuµky k celkovému poètu dotazov nad tabuµkou. hand. \texttt{hit-rate} sa v¹ak dynamicky so zmenami v tabuµke mení, èím dochádza k zmene veµkosti tabuµky.

\subsection{Zhrnutie}
Balík CacBDD je ïal¹í kvalitne spracovaný balík pre prácu s BDD. Vyu¾íva indexový prístup k uzlom. Návrhári balíku sa zamerali hlavne na jeho rýchlos», ktorá je dos» vysoká vzhµadom k implementácií dynamického ukladania medzivýsledkov. V literatúre\cite{cacbdd} je mo¾né nájs» aj rýchlostné zrovnanie s balíkom CUDD. 










\chapter{Návrh a implementácia}
V tejto kapitole popí¹em svôj návrh implementácie jednotlivých dátových ¹truktúr a algoritmov.

\section{Dátové ¹truktúry}
V tejto èasti sa zoznámime s návrhom jednotlivých dátových ¹truktúr, ako sú navzájom previazané a ktorá polo¾ka ¹truktúry na èo slú¾i.

\subsection{BDD uzol}\label{tBddNode}
Základnou jednotkou ka¾dého grafu je uzol. Môj návrh uzlu obsahuje v¹etky dôle¾ité premenné pre úplnu prácu s ním.
\begin{lstlisting}
typedef struct BddNode{
  struct BddNode *high, *low;
  unsigned int var;
  unsigned int ref;
  struct BddNode *nextFree;
}tBddNode;
\end{lstlisting}
Premenné \texttt{high} a \texttt{low} sú ukazatele na vysokého a nízkeho následníka uzlu. V prípade, ¾e ide o terminálny uzol, \texttt{high} a \texttt{low} sú nastavené na \texttt{NULL}. Na zistenie, èi je daný uzol terminálny sa pou¾íva makro \texttt{isTerminal(t)}. Premenná \texttt{var} je index do tabuµky mien premenných, ktorú si detailnej¹ie popí¹eme v sekcií \ref{tLabels}. Premenné \texttt{ref} a \texttt{nextFree} sú premenné, ktoré vyu¾íva garbage collector. \texttt{ref} je poèítadlo referencií, ktoré je dôle¾ité pri zdielaných uzloch a \texttt{nextFree} je ukazateµ, ktorý previazáva zoznam voµných premenných ktoré má k dispozícií manager. Manageru sa budeme viac venova» v èasti \ref{tManager}.

\subsection{Garbage collector}\label{tGarbage}
Garbage collector má jednoduchú ¹truktúru.
\begin{lstlisting}
typedef struct Garbage{
  tBddNode *nodes;
  struct Garbage *next;
}tGarbage;
\end{lstlisting}
Premenná \texttt{nodes} ukazuje na pole v¹etkých uzlov a premenná \texttt{next} na pola ïal¹ieho kusu pamäti, ktorý sa alokuje v prípade, ¾e manager nemá voµné uzly.

\subsection{Mená premenných} \label{tLabels}
Je indexované pole re»azcov. ©truktúra je taktie¾ veµmi jednoduchá.
\begin{lstlisting}
typedef struct Labels{
  char **lab;
  unsigned int count;
}tLabels;
\end{lstlisting}
Premenná \texttt{lab} je odkaz na pole re»azcov\footnote{Re»azcom je myslený typ \texttt{char *}.} a \texttt{count} je premenná oznaèujúca poèet re»azcov, pou¾ívana hlavne pri realokácií prvej úrovne \texttt{lab}.

\subsection{Medzivýsledky\,--\,\emph{Cache}} \label{tCache}
Medzivýsledky zni¾ujú pamä»ové nároky na tvorbu BDD a zjednodu¹ujú zdielanie podgrafov. ©truktúra je nasledujúca. Implementácia medzivýsledkov je ako hashovacia tabuµka, ktorej klúè pre daný uzol sa spoèíta z trojice $[high,low,var]$ daného uzlu. Dátová ¹truktúra nesúca informáciu tj. trojicu $[high,low,var]$ a ukazateµ na uzol obsahujúci túto trojicu je nasledovná.
\begin{lstlisting}
typedef struct CacheItem{
  unsigned int var;
  tBddNode *high, *low, *address;
  struct CacheItem * next;
} tCacheItem;
\end{lstlisting}
Premenné \texttt{high},\texttt{low},\texttt{var} a \texttt{address} nesú informáciu o uzle. Premenná \texttt{next} preväzuje uzly. V prípade ¾e je uzol voµný tvorí zoznam so v¹etkými voµnými uzlami, v prípade ¾e je uzol pou¾ívaný, tvorí zoznam v hashovacej tabuµke. Táto ¹truktúra, podobne ako ¹truktúra \texttt{tNodes} sa alokuje ako pole, ktoré je ulo¾ené v bloku \texttt{tCacheGar}. ©truktúra je nasledujúca.
\begin{lstlisting}
typedef struct CacheGar{
  tCacheItem * nodes;
  struct CacheGar * next;
} tCacheGar;
\end{lstlisting}
Premenná \texttt{nodes} ukazuje na pole odkiaµ sa priradzujú cache záznamy. \texttt{next} zabezpeèuje previazanie týchto ¹truktúr do zoznamu. Ïal¹í blok ¹truktúry sa alokuje v prípade, ¾e poèet voµných cache záznamov je 0. Toto zistíme zo zastre¹ujúcej ¹truktúry \texttt{tCache}.
\begin{lstlisting}
typedef struct Cache {
  tCacheGar * gar;
  tCacheItem * free;
  tCacheItem ** hash;
} tCache;
\end{lstlisting}
Nosná ¹truktúra, ktorá má nastaros» celý managment medzivýsledkov. \texttt{gar} je zoznam v¹etkých záznamov, ktoré mô¾eme pou¾i». \texttt{free} sú previazané zatiaµ nepou¾ité uzly. \texttt{hash} je odkaz do hashovacej tabuµky, do ktorej sa ukadajú záznamy medzivýsledkov.


\subsection{BDD manager}\label{tManager}
Zastre¹ujúca ¹truktúra, riadiaca celú tvorbu a úpravy BDD.
\begin{lstlisting}
typedef struct Manager{
  tGarbage *nodes;
  tBddNode *free;
  tLabels *variables;
  tLabels *terminals;
  tCache *cache;
}tManager;
\end{lstlisting}
\texttt{nodes} je ukazateµ na ¹truktúru garbage collectoru, ktorá ma nastarosti uvoµnovanie a vytváranie nových zhlukov uzlov. \texttt{free} je ukazateµ na prvý voµný uzol. Ide opä» o zoznamovú implementáciu, kde sú v¹etky uzly prepojené pomocou \texttt{nextFree}, popísaného v èas»i \ref{tBddNode}. \texttt{cache} je ¹truktúra starajúca sa o vytváranie medzivýsledkov. \texttt{variables} a \texttt{terminals} sú tabuµky mien uzlov. 

\subsection{Výèet chybových stavov}
Balíèek sa mô¾e pri pou¾ívaní nachádza» v nejakom chybovom stave. Tieto chybové stavy sú zapúzdrené vo výètovom type \texttt{tError}. Balík disponuje makrom \texttt{bddThrowError(tError e, tManager *mgr)}, ktoré v prípade vzniknutej chyby ukonèuje program s odpovedajúcou správou pre u¾ivateµa. Makro vytlaèí odpovedajúcu chybovú hla¹ku k chybe predanej parametrom \texttt{e}, uvoµní prostriedky managera predaného parametrom \texttt{mgr} a ukonèuje program chybovým kódom \texttt{e}.

\section{Algoritmy}
Hlavné u¾ivateµské rozhranie tvoria funkcie \texttt{bddInit()}, ktorá inicializuje v¹etky komponenty pre manager, \texttt{bddDestroy()}, ktorá uvoµnuje v¹etky prostriedky, ktoré daný manager alokoval, \texttt{bddCreateNode()} a \texttt{bddCreateTerminal()}, ktoré vytvoria uzol pre danú premennú alebo terminál a funkcia \texttt{bddApply()}. 

\subsection{Inicializácia}
®iadnu z operácií nie je mo¾né prevádza» nad neinicializovaným managerom. Na inicializáciu slú¾i funkcia \texttt{bddInit(tManager *mgr, unsigned int size)}, ktorá postupne inicializuje v¹etky prvky premennej \texttt{mgr}. Najdôle¾itej¹iu èas»ou je inicializácia premennej \texttt{nodes}, ktorá vytvorí pole uzlov podµa zadanej veµkosti. V¹etky tieto uzly sú prístupné zo zoznamu v premennej \texttt{free}. Automaticky sa generujú dva uzly \texttt{bddFalse} a \texttt{bddTrue} prístupné na globálnej úrovni. Funckia zapúzdruje inicializáciu v¹etkých vlastných premenných.

Parameter \texttt{size} je veµkos» na akú sa manager inicializuje. V balíku sú 3 preddefinované kon¹tanty a to \texttt{BDD\_SMALL}, \texttt{BDD\_MEDIUM} a \texttt{BDD\_LARGE}.

\subsection{Uvolòovanie}
Na uvolnenie slú¾i funkcia \texttt{bddDestroy(tManager *mgr)}, ktorá postupne zru¹í v¹etky alokované ¹truktúry. Je neprípustné ukonèi» program pred zavolaním tejto funkcie, preto ¾e by dochádzalo k únikom pamäti.

Postupne sa uvolòujú prostriedky garbage collectora, tj. zru¹ia sa uzly a potom sa dealokuje ¹truktúra. Je potreba dáva» pozor na to, ¾e garbage collector je zoznam, teda je potrebné ho uvolni» korektne celý a nie iba prvý blok pamäti. Cache tvorí taktie¾ zoznam, preto sa musí uvolòova» postupne. Uvolnenie ¹truktúry návestí je iba volanie funkcie \texttt{free()} nad premennou ¹truktúry \texttt{lab}. Ïalej sa u¾ uvolòuje iba samotná ¹truktúra. 

Premenná \texttt{free} je iba pomocný ukazateµ, teda sa neuvoµnuje. Miesto ktoré odkazoval bolo uvoµnené pri uvoµnovaní premennej \texttt{nodes}.

\subsection{Vytvorenie uzlu}
Na vytváranie uzlov sa pou¾íva funkcia \texttt{bddCreateNode(tManager *mgr, char *label, tBddNode * high, tBddNode * low, tBddNode **res)}. Parametry funkcie sú \texttt{mgr} èo¾ je manager nad ktorým pracujeme, \texttt{label} je meno vytváraného uzlu, ktoré sa ukladá do premennej manageru \texttt{variables}, \texttt{high} a \texttt{low} sú ukazatele na potomkov a \texttt{res} je výstupný parameter, cez ktorý vraciame ukazateµ na uzol. Návratová hodnota funkcie je chybový kód v prípade, ¾e nám do¹la pamä». Funkcia nastavuje uzlu v¹etky jeho informácie a to takto:
\begin{enumerate}
  \item Nastavíme premennú \texttt{var} na index v tabuµke \texttt{variables}.
  \item Prehµadáme medzivýsledky, èi takýto uzol u¾ neexistuje.
  \begin{itemize}
    \item Ak existuje, vraciame ukazateµ z medzivýsledkov.
    \item Ak neexistuje, pokraèujeme.
  \end{itemize}
  \item Poèítadlo referencií \texttt{ref} nastavíme na 1.
  \item Oznaèíme uzol ako pou¾ívaný nastavením \texttt{nextFree} na \texttt{NULL}.
  \item Vysokému následníkovi uzlu \texttt{high} priradíme hodnotu parametru \texttt{high}.
  \item Nízkemu následníkovi uzlu \texttt{low} priradíme hodnotu parametru \texttt{low}.
\end{enumerate}
V prípade nového terminálneho uzla sa pou¾íva funkcia \texttt{bddCreateTerminal(tManager *mgr,char *label,tBddNode **res)}. Parametre reprezentujú to isté ako vo funkcií \texttt{bddCreateNode()}. Sú tu iba nepatrné zmeny v implementácií:
\begin{itemize}
  \item Návestie sa vkladá do tabuµky \texttt{terminals}.
  \item Referencie sa na terminálnych uzloch nepoèítajú.
  \item Do \texttt{high} a \texttt{low} priradíme \texttt{NULL}.
\end{itemize}

\subsection{Práca s mezdivýsledkami\,--\,\emph{Cacheovanie}} 
Ka¾dý vytvorený uzol (s výnimkou terminálnych) sa ukladá do ¹truktúry uvedenej v èasti \ref{tCache}. Ukladajú sa ako trojica vysokého následníka, nízkeho následníka a návestia premennej. Ïalej sa ukladá adresa tohto uzlu. Pri vytváraní uzlu najskôr skontrolujeme medzivýsledky pomocou funckie \texttt{cacheCheck(tCache *c, tBddNode *high, tBddNode *low, unsigned int var)}. Ak daný uzol u¾ existuje, funkcia vracia ukazateµ na uzol. V prípade ¾e uzol e¹te neexistuje, vracia sa \texttt{NULL}. V tomto prípade sa uzol vkladá do cache pomocou funkcie \texttt{cacheInsert()}.

\subsection{Práca s referenciami}
Pre prácu s referenciami sa pou¾ívajú dve funkcie a to \texttt{nodeIncRef(tBddNode *node)} a \texttt{nodeDecRef(tManager *mgr, tBddNode *node)}.

Funkcia \texttt{nodeIncRef(tBddNode *node)} zvy¹uje poèítadlo referencií na uzol. Volá sa implicitne pri vytváraní uzlu za predpokladu, ¾e uzol u¾ existuje a bol najdený v medzivýsledkoch.

Funkcia \texttt{nodeDecRef(tManager * mgr, tBddNode *node)} naopak zni¾uje poèítadlo referencií. Programátor ju musí vola» explicitne nad ka¾dým ukazateµom na graf, ktorý u¾ nemieni pou¾íva». V prípade, ¾e poèítadlo referencií daného uzlu klesne na 0, uzol je automaticky uvoµnený z pou¾ívaných uzlov aj z medzivýsledkov. Funkcia sa rekurzívne volá aj na potomkov. Takýmto spôsobom sa dajú ru¹i» celé zhluky uzlov.

\subsection{Procedúra \emph{Apply()}} 
Základný princíp procedúry bol u¾ popísaný v èasti \ref{apply}. Implementáciu v kni¾nici tvoria dve funkcie. Prvá je \texttt{bddApply(tManager *mgr,tBddNode *x, tBddNode *y, tBddNode* (*func) (tBddNode *, tBddNode *))}, ktorá sa volá z u¾ivateµského programu. Ako parameter dostáva dva ukazatele na grafy (\texttt{x} a \texttt{y}), manager, v ktorom sa má procedúra vykona» (\texttt{mgr}) a odkaz na funkciu vracajúcu nový diagram (\texttt{func}). Funkcia spú¹»a rekurzívnu funkciu \texttt{\_apply()} s rovnakými parametrami. \texttt{\_apply()} sa rekurzívne zanoruje podµa algoritmu \ref{algApply} popísaného v èasti \ref{apply}. 

Pri vytváraní nových uzlov v procedúre sa pou¾íva funkcia \texttt{bddNewNode(tManager *mgr, unsigned int var, tBddNode *high, tBddNode *low, tBddNode **res)}, ktorá vytvára nový uzol s tým rozdielom, ¾e nekontroluje medzivýsledky. Funkcia \texttt{\_apply} kontroluje medzivýsledky a¾ pri rekurzívnom vynorovaní, keï sa pridajú danému uzlu korektní potomkovia. Taktie¾ sa pri vynorovaní kontroluje, èi potomkovia nie sú rovnakí. V takom prípade sa uzol ru¹í a vracia sa ukazateµ na potomka.

Kni¾nica disponuje základnými logickými funkciami, ktoré mô¾u by» ako parameter funkcie \texttt{bddApply()}. Tieto funkcie sú \texttt{bddOr()}, \texttt{bddNor()}, \texttt{bddAnd()}, \texttt{bddNand()}, \texttt{bddXor()}, \texttt{bddImp()} a \texttt{bddNeg()}.  V prípade pou¾itia \texttt{bddNeg()}, funkcia \texttt{bddApply()} predáva ako parameter funkcie \texttt{\_apply()} dva rovnaké ukazateµe na grafy a funkciu \texttt{bddNand()}.

\subsection{Práca s MTBDD}
Ako bolo u¾ vy¹¹ie spomínané, balík pracuje na globálnej úrovni kvôli premenným \texttt{bddTrue} a \texttt{bddFalse}. Z tohto dôvodu pri práci s MTBDD musí u¾ivateµ vytvára» uzly na globálnej úrovni. To znaène obmedzuje prácu s nekoneènými mno¾inami. Inak sa s MTBDD pracuje rovnakým spôsobom ako s BDD. 

\subsection{Uká¾ky kódov}
Predvedieme si niektoré kon¹trukcie, ktoré sa vyu¾ívajú na tvorbu rozhodovacích diagramov.

\subsubsection{Jednoduchá binárna funkcia}
Nasledujúci kód vytvorí funkciu 
$$f(a,b,c) = (a\wedge \neg b) \vee (\neg c\wedge d)$$

\begin{lstlisting}
#include "bdd.h"

int main() {
  tError e;
  tManager manager;
  tBddNode *a, *b, *c, *d, *tmp;
  
  e = bddInit(&manager,BDD_SMALL);
  if(e) bddThrowError(e,&manager);

  e = bddCreateNode(&manager,"a",bddTrue,bddFalse,&a);
  if(e) bddThrowError(e,&manager);
  e = bddCreateNode(&manager,"b",bddFalse,bddTrue,&b);
  if(e) bddThrowError(e,&manager);
  e = bddCreateNode(&manager,"c",bddTrue,bddFalse,&tmp);
  if(e) bddThrowError(e,&manager);
  c = bddApply(&manager,tmp,NULL,bddNeg);
  nodeDecRef(&manager,tmp);
  
  e = bddCreateNode(&manager,"d",bddTrue,bddFalse,&d);
  if(e) bddThrowError(e,&manager);
  
  tmp = bddApply(&manager,a,b,bddAnd);
  nodeDecRef(&manager,a);
  nodeDecRef(&manager,b);
  
  a = bddApply(&manager,c,d,bddAnd);
  nodeDecRef(&manager,c);
  nodeDecRef(&manager,d);
  
  b = bddApply(&manager,a,tmp,bddOr);
  nodeDecRef(&manager,a);
  nodeDecRef(&manager,tmp);

  printTree(&manager,b);

  bddDestroy(&manager);
  return 0;
}
\end{lstlisting}
Teraz si tro¹ku detailnej¹ie rozoberieme kód. Na zaèiatku inicializujeme manager. Postupne vytvárame uzly pre premenné $a$,$b$,$c$ a $d$. Sú tu ukázané dva rôzne druhy vytvorenia uzlu popisujúceho negáciu. Prvý je pri inicializácií premennej \texttt{b} pomocou vymenených parametrov \texttt{high} a \texttt{low}. Druhý je pomocou funkcie \texttt{bddApply()} a funkcie negácie.

Po ka¾dom volaní funkcie \texttt{bddApply()} je volaná funkcia \texttt{nodeDecRef()} nad grafmi predanými ako parameter \texttt{bddApply()}. Je to z dôvodu, ¾e \texttt{bddApply()} nijako nemodifikuje pôvodné grafy a vytvára úplne nové. Pokiaµ nechceme u¾ s ukazateµmi pracova», je potrebné zní¾i» poèítadlo referencií uzla na ktorý ukazujú. Potom je mo¾né ukazateµ pou¾íva» u¾ µubovoµne.

Pred skonèením programu je nutné vola» funkciu \texttt{bddDestroy()}, ktorá uvoµní v¹etky alokované prostriedky. 

\subsubsection{Práca s MTBDD}
Práca s MTBDD je analogická ako práca s BDD. V podstate sa lí¹i iba v tom, ¾e úplne na zaèiatku práce sa vytvárajú vlastné terminálne uzly pomocou funkcie \texttt{bddCreateTerminal()}. 

Ako uká¾ku som zvolil funkciu zo obrázka \ref{picMTBDD}. Systém sa dá popísa» tabuµkou výsledných stavov uplatenia funkcie na jednotlivé terminály. tabuµka je nasledujúca: 
\begin{center}
  \begin{tabular}{|c|c c c c|}
    \hline
    $\mathit{func}(x,y)$ & $\mathit{S_{off}}$ & $\mathit{S_{on}}$    & $\mathit{S_{set}}$   & $\mathit{S_{count}}$  \\ 
    \hline
    $\mathit{S_{off}}$   & $\mathit{S_{off}}$ & $\mathit{S_{off}}$   & $\mathit{S_{off}}$   & $\mathit{S_{off}}$  \\ 
    $\mathit{S_{on}}$    & $\mathit{S_{off}}$ & $\mathit{S_{on}}$    & $\mathit{S_{set}}$   & $\mathit{S_{count}}$ \\ 
    $\mathit{S_{set}}$   & $\mathit{S_{off}}$ & $\mathit{S_{set}}$   & $\mathit{S_{set}}$   & $\mathit{S_{count}}$ \\ 
    $\mathit{S_{count}}$ & $\mathit{S_{off}}$ & $\mathit{S_{count}}$ & $\mathit{S_{count}}$ & $\mathit{S_{count}}$ \\ \hline
  \end{tabular}
\end{center}
Tabuµka zna¾í prechodovú funckiu ná¹ho systému. Implementácia pomocou kni¾nice je nasledujúca
\begin{lstlisting}
#include"bdd.h"

tBddNode * Son, *Soff, *Sset, *Scount;

tBddNode * func(tBddNode *x, tBddNode *y){
  if(x == y)                  return x;
  if(x == Soff || y == Soff)  return Soff;
  if(x == Son)                return y;
  if(y == Son)                return x;
  return Scount;
}

int main(){
  tManager mgr;
  tBddNode *xOnOff, *xSetCount, *tmp;
  
  bddInit(&mgr,BDD_SMALL);

  bddCreateTerminal(&mgr,"S_on",   &Son);
  bddCreateTerminal(&mgr,"S_off",  &Soff);
  bddCreateTerminal(&mgr,"S_set",  &Sset);
  bddCreateTerminal(&mgr,"S_count",&Scount);
  
  bddCreateNode(&mgr,"X_on_off",   Son, Soff,  &xOnOff);
  bddCreateNode(&mgr,"X_count_set",Scount,Sset,&xSetCount);
  
  tmp = bddApply(&mgr,xOnOff,xSetCount,func);
  nodeDecRef(&mgr,xOnOff);
  nodeDecRef(&mgr,xSetCount);
  
  printTree(&mgr,tmp);
  
  bddDestroy(&mgr);
}
\end{lstlisting}
Z priestorových dôvodov som odtranil o¹etrovanie chybových stavov funkcií \texttt{bddInit()} a \texttt{bddCreateTerminal()}. Ako vidíme, práca s MTBDD je veµmi podobná práci s BDD, s tým rozdielom, ¾e sami vytvárame terminálne uzly a funkcie nad nimi.

\section{Programátorské rozhranie}
Programátor by mal vyu¾íva» iba funkcie urèené pre vonkaj¹iu prácu s balíkom, pou¾ívanie vnútorných funkcií balíka mô¾e spôsobi» nepredvídateµné správanie. Funkcie urèené pre programátora sú:
\begin{itemize}
  \item\texttt{tError bddInit(tManager *mgr, unsigned int size)},
  \item\texttt{void bddDestroy(tManager *mgr)},
  \item\texttt{tBddNode *bddApply(tManager *mgr, tBddNode *x, tBddNode *y, tBddNode *(*func) (tBddNode *, tBddNode *))},
  \item\texttt{tBddNode *bddCreateNode(tManager *mgr,char *label, tBddNode *high, tBddNode *low, tBddNode **result)},
  \item\texttt{tBddNode *bddCreateTerminal(tManager *mgr,char *label, tBddNode **result)},
  \item\texttt{void nodeDecRef(tManager *mgr, tBddNode *node)},
  \item makro \texttt{bddThrowError(tError e, tManager *mgr)},
  \item mno¾ina booleovských funkcií
  \begin{itemize}
\item\texttt{tBddNode *bddOr(tBddNode *x,tBddNode *y)},
\item\texttt{tBddNode *bddNor(tBddNode *x,tBddNode *y)},
\item\texttt{tBddNode *bddAnd(tBddNode *x,tBddNode *y)},
\item\texttt{tBddNode *bddNand(tBddNode *x,tBddNode *y)},
\item\texttt{tBddNode *bddXor(tBddNode *x,tBddNode *y)},
\item\texttt{tBddNode *bddImp(tBddNode *x,tBddNode *y)},
\item\texttt{tBddNode *bddNeg(tBddNode *x,tBddNode *y)}
  \end{itemize}
\end{itemize}

\chapter{Testy}
V tejto kapitole popí¹em ako bol balík testovaný.
\section{Uniky pamäti}
Dealokáciu v¹etkých dátových ¹truktúr súvisiacich s BDD má nastarosti procedúra \texttt{bddDestroy( tManager *mgr)}. Na testovanie pamäti som pou¾il nástroj \texttt{valgrind}\footnote{\url{http://valgrind.org/}.}. Testy sú zamerané hlavne na správnos» uvolòovania v¹etkých vyu¾ívaných zdrojov. Samozrejme \text{valgrind} automaticky kontroluje, èi nepracujeme s neinicializovanými premennými alebo èi nesiahame do pamäti, kam prístup nemáme. Pokiaµ nebude povedané inak, v¹etky testy sa vykonávajú nad managerom inicializovaným na veµkos» \texttt{BDD\_SMALL}

\paragraph{Inicializácia} V programe sa volá inicializácia managera pomocou funkcie \texttt{bddInit()} a následne sa volá funkcia \texttt{bddDestroy()}, ktorá by mala korektne uvoµni» v¹etky alokované èasti pamäte. Zdrojový kód sa nachádza v \texttt{./tests/test-init.c} a spú¹»a sa pomocou príkazu \texttt{make t-init} v koreòovom adresári.\\
\texttt{make t-init\\
==24458== HEAP SUMMARY:\\
==24458==     in use at exit: 0 bytes in 0 blocks\\
==24458==   total heap usage: 10 allocs, 10 frees, 8,856 bytes allocated\\
==32244== All heap blocks were freed -- no leaks are possible}\\

\paragraph{Jednoduchá funkcia} Program inicializuje managera, a vytvorí jednoduchú logickú funkciu o 3 logických premenných. Funkcia je nasledujúca $$f(a,b,c)=(\neg a \wedge b)\vee(a\wedge \neg b \wedge \neg c).$$ Kód je ulo¾ený v \texttt{./tests/test-simplyf.c} a spú¹»a sa príkazom \texttt{make t-simplyf} v koreòovom adresári.\\
\texttt{make t-simplyf\\
==24458== HEAP SUMMARY:\\
==24458==     in use at exit: 0 bytes in 0 blocks\\
==32244==   total heap usage: 13 allocs, 13 frees, 8,904 bytes allocated\\
==32244== All heap blocks were freed -- no leaks are possible}\\

\paragraph{Zlo¾itá funkcia} Program inicializuje managera a vykonáva nad ním nasledujúcu funkciu $$f(x_1\,\dots,x_{33})=(x_1\wedge \dots \wedge x_{33}),$$ Manager sa inicializuje na veµkos» 16. Tento test sleduje prácu s novými blokmi pamäte a s cache. Kód je ulo¾ený v \texttt{./tests/test-bigf.c} a spú¹»a sa príkazom \texttt{make t-bigf}.\\
\texttt{make t-bigf\\
==11659== HEAP SUMMARY:\\
==11659==     in use at exit: 0 bytes in 0 blocks\\
==11659==   total heap usage: 65 allocs, 65 frees, 30,544 bytes allocated\\
==11659== All heap blocks were freed -- no leaks are possible}\\

\paragraph{Zhrnutie testov zameraných na pamä»} Pri korektom pou¾ívaní, kni¾nica nemá problém s alokáciou a uvoµnovaním zdrojov, nespôsobuje úniky pamäte a nespôsobuje neoprávnené prístupy do pamäti.


\chapter{Porovnanie s kni¾nicou CUDD}



\chapter{Závìr}

